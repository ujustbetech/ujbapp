{"version":3,"sources":["input-shims-a4fc53ac-js-es5.js","webpack:///node_modules/@ionic/core/dist/esm/input-shims-a4fc53ac.js"],"names":[],"mappings":"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","file":"x","sourcesContent":["(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"input-shims-a4fc53ac-js\"],{\n\n/***/ \"./node_modules/@ionic/core/dist/esm/input-shims-a4fc53ac.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@ionic/core/dist/esm/input-shims-a4fc53ac.js ***!\n  \\*******************************************************************/\n/*! exports provided: startInputShims */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startInputShims\", function() { return startInputShims; });\n/* harmony import */ var _helpers_46f4a262_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers-46f4a262.js */ \"./node_modules/@ionic/core/dist/esm/helpers-46f4a262.js\");\n\n\nconst cloneMap = new WeakMap();\r\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\r\n    if (cloneMap.has(componentEl) === shouldRelocate) {\r\n        return;\r\n    }\r\n    if (shouldRelocate) {\r\n        addClone(componentEl, inputEl, inputRelativeY);\r\n    }\r\n    else {\r\n        removeClone(componentEl, inputEl);\r\n    }\r\n};\r\nconst isFocused = (input) => {\r\n    return input === input.getRootNode().activeElement;\r\n};\r\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\r\n    // this allows for the actual input to receive the focus from\r\n    // the user's touch event, but before it receives focus, it\r\n    // moves the actual input to a location that will not screw\r\n    // up the app's layout, and does not allow the native browser\r\n    // to attempt to scroll the input into place (messing up headers/footers)\r\n    // the cloned input fills the area of where native input should be\r\n    // while the native input fakes out the browser by relocating itself\r\n    // before it receives the actual focus event\r\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\r\n    const parentEl = inputEl.parentNode;\r\n    // DOM WRITES\r\n    const clonedEl = inputEl.cloneNode(false);\r\n    clonedEl.classList.add('cloned-input');\r\n    clonedEl.tabIndex = -1;\r\n    parentEl.appendChild(clonedEl);\r\n    cloneMap.set(componentEl, clonedEl);\r\n    const doc = componentEl.ownerDocument;\r\n    const tx = doc.dir === 'rtl' ? 9999 : -9999;\r\n    componentEl.style.pointerEvents = 'none';\r\n    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\r\n};\r\nconst removeClone = (componentEl, inputEl) => {\r\n    const clone = cloneMap.get(componentEl);\r\n    if (clone) {\r\n        cloneMap.delete(componentEl);\r\n        clone.remove();\r\n    }\r\n    componentEl.style.pointerEvents = '';\r\n    inputEl.style.transform = '';\r\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\r\n    if (!scrollEl || !inputEl) {\r\n        return () => { return; };\r\n    }\r\n    const scrollHideCaret = (shouldHideCaret) => {\r\n        if (isFocused(inputEl)) {\r\n            relocateInput(componentEl, inputEl, shouldHideCaret);\r\n        }\r\n    };\r\n    const onBlur = () => relocateInput(componentEl, inputEl, false);\r\n    const hideCaret = () => scrollHideCaret(true);\r\n    const showCaret = () => scrollHideCaret(false);\r\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\r\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\r\n    inputEl.addEventListener('blur', onBlur);\r\n    return () => {\r\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\r\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\r\n        inputEl.addEventListener('ionBlur', onBlur);\r\n    };\r\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur]';\r\nconst enableInputBlurring = () => {\r\n    let focused = true;\r\n    let didScroll = false;\r\n    const doc = document;\r\n    const onScroll = () => {\r\n        didScroll = true;\r\n    };\r\n    const onFocusin = () => {\r\n        focused = true;\r\n    };\r\n    const onTouchend = (ev) => {\r\n        // if app did scroll return early\r\n        if (didScroll) {\r\n            didScroll = false;\r\n            return;\r\n        }\r\n        const active = doc.activeElement;\r\n        if (!active) {\r\n            return;\r\n        }\r\n        // only blur if the active element is a text-input or a textarea\r\n        if (active.matches(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        // if the selected target is the active element, do not blur\r\n        const tapped = ev.target;\r\n        if (tapped === active) {\r\n            return;\r\n        }\r\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        focused = false;\r\n        // TODO: find a better way, why 50ms?\r\n        setTimeout(() => {\r\n            if (!focused) {\r\n                active.blur();\r\n            }\r\n        }, 50);\r\n    };\r\n    doc.addEventListener('ionScrollStart', onScroll);\r\n    doc.addEventListener('focusin', onFocusin, true);\r\n    doc.addEventListener('touchend', onTouchend, false);\r\n    return () => {\r\n        doc.removeEventListener('ionScrollStart', onScroll, true);\r\n        doc.removeEventListener('focusin', onFocusin, true);\r\n        doc.removeEventListener('touchend', onTouchend, false);\r\n    };\r\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\r\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\r\n    const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\r\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\r\n};\r\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\r\n    // compute input's Y values relative to the body\r\n    const inputTop = inputRect.top;\r\n    const inputBottom = inputRect.bottom;\r\n    // compute visible area\r\n    const visibleAreaTop = contentRect.top;\r\n    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\r\n    // compute safe area\r\n    const safeAreaTop = visibleAreaTop + 15;\r\n    const safeAreaBottom = visibleAreaBottom * 0.5;\r\n    // figure out if each edge of the input is within the safe area\r\n    const distanceToBottom = safeAreaBottom - inputBottom;\r\n    const distanceToTop = safeAreaTop - inputTop;\r\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\r\n    const desiredScrollAmount = Math.round((distanceToBottom < 0)\r\n        ? -distanceToBottom\r\n        : (distanceToTop > 0)\r\n            ? -distanceToTop\r\n            : 0);\r\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\r\n    // gets focus, so make sure we don't scroll the input above the visible area\r\n    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\r\n    const distance = Math.abs(scrollAmount);\r\n    const duration = distance / SCROLL_ASSIST_SPEED;\r\n    const scrollDuration = Math.min(400, Math.max(150, duration));\r\n    return {\r\n        scrollAmount,\r\n        scrollDuration,\r\n        scrollPadding: keyboardHeight,\r\n        inputSafeY: -(inputTop - safeAreaTop) + 4\r\n    };\r\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, keyboardHeight) => {\r\n    let coord;\r\n    const touchStart = (ev) => {\r\n        coord = Object(_helpers_46f4a262_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(ev);\r\n    };\r\n    const touchEnd = (ev) => {\r\n        // input cover touchend/mouseup\r\n        if (!coord) {\r\n            return;\r\n        }\r\n        // get where the touchend/mouseup ended\r\n        const endCoord = Object(_helpers_46f4a262_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(ev);\r\n        // focus this input if the pointer hasn't moved XX pixels\r\n        // and the input doesn't already have focus\r\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            // begin the input focus process\r\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\r\n        }\r\n    };\r\n    componentEl.addEventListener('touchstart', touchStart, true);\r\n    componentEl.addEventListener('touchend', touchEnd, true);\r\n    return () => {\r\n        componentEl.removeEventListener('touchstart', touchStart, true);\r\n        componentEl.removeEventListener('touchend', touchEnd, true);\r\n    };\r\n};\r\nconst jsSetFocus = (componentEl, inputEl, contentEl, keyboardHeight) => {\r\n    const scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\r\n    if (Math.abs(scrollData.scrollAmount) < 4) {\r\n        // the text input is in a safe position that doesn't\r\n        // require it to be scrolled into view, just set focus now\r\n        inputEl.focus();\r\n        return;\r\n    }\r\n    // temporarily move the focus to the focus holder so the browser\r\n    // doesn't freak out while it's trying to get the input in place\r\n    // at this point the native text input still does not have focus\r\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\r\n    inputEl.focus();\r\n    // scroll the input into place\r\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(() => {\r\n        // the scroll view is in the correct position now\r\n        // give the native text input focus\r\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\r\n        // ensure this is the focused input\r\n        inputEl.focus();\r\n    });\r\n};\r\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\r\n    if (startCoord && endCoord) {\r\n        const deltaX = (startCoord.x - endCoord.x);\r\n        const deltaY = (startCoord.y - endCoord.y);\r\n        const distance = deltaX * deltaX + deltaY * deltaY;\r\n        return distance > (threshold * threshold);\r\n    }\r\n    return false;\r\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\r\nconst enableScrollPadding = (keyboardHeight) => {\r\n    const doc = document;\r\n    const onFocusin = (ev) => {\r\n        setScrollPadding(ev.target, keyboardHeight);\r\n    };\r\n    const onFocusout = (ev) => {\r\n        setScrollPadding(ev.target, 0);\r\n    };\r\n    doc.addEventListener('focusin', onFocusin);\r\n    doc.addEventListener('focusout', onFocusout);\r\n    return () => {\r\n        doc.removeEventListener('focusin', onFocusin);\r\n        doc.removeEventListener('focusout', onFocusout);\r\n    };\r\n};\r\nconst setScrollPadding = (input, keyboardHeight) => {\r\n    if (input.tagName !== 'INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement &&\r\n        input.parentElement.parentElement &&\r\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\r\n        return;\r\n    }\r\n    const el = input.closest('ion-content');\r\n    if (el === null) {\r\n        return;\r\n    }\r\n    const timer = el[PADDING_TIMER_KEY];\r\n    if (timer) {\r\n        clearTimeout(timer);\r\n    }\r\n    if (keyboardHeight > 0) {\r\n        el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\r\n    }\r\n    else {\r\n        el[PADDING_TIMER_KEY] = setTimeout(() => {\r\n            el.style.setProperty('--keyboard-offset', '0px');\r\n        }, 120);\r\n    }\r\n};\n\nconst INPUT_BLURRING = true;\r\nconst SCROLL_PADDING = true;\r\nconst startInputShims = (config) => {\r\n    const doc = document;\r\n    const keyboardHeight = config.getNumber('keyboardHeight', 290);\r\n    const scrollAssist = config.getBoolean('scrollAssist', true);\r\n    const hideCaret = config.getBoolean('hideCaretOnScroll', true);\r\n    const inputBlurring = config.getBoolean('inputBlurring', true);\r\n    const scrollPadding = config.getBoolean('scrollPadding', true);\r\n    const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\r\n    const hideCaretMap = new WeakMap();\r\n    const scrollAssistMap = new WeakMap();\r\n    const registerInput = (componentEl) => {\r\n        const inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\r\n        const scrollEl = componentEl.closest('ion-content');\r\n        if (!inputEl) {\r\n            return;\r\n        }\r\n        if ( !!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\r\n            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\r\n            hideCaretMap.set(componentEl, rmFn);\r\n        }\r\n        if ( !!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\r\n            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\r\n            scrollAssistMap.set(componentEl, rmFn);\r\n        }\r\n    };\r\n    const unregisterInput = (componentEl) => {\r\n        if ( hideCaret) {\r\n            const fn = hideCaretMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            hideCaretMap.delete(componentEl);\r\n        }\r\n        if ( scrollAssist) {\r\n            const fn = scrollAssistMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            scrollAssistMap.delete(componentEl);\r\n        }\r\n    };\r\n    if (inputBlurring && INPUT_BLURRING) {\r\n        enableInputBlurring();\r\n    }\r\n    if (scrollPadding && SCROLL_PADDING) {\r\n        enableScrollPadding(keyboardHeight);\r\n    }\r\n    // Input might be already loaded in the DOM before ion-device-hacks did.\r\n    // At this point we need to look for all of the inputs not registered yet\r\n    // and register them.\r\n    for (const input of inputs) {\r\n        registerInput(input);\r\n    }\r\n    doc.addEventListener('ionInputDidLoad', ((ev) => {\r\n        registerInput(ev.detail);\r\n    }));\r\n    doc.addEventListener('ionInputDidUnload', ((ev) => {\r\n        unregisterInput(ev.detail);\r\n    }));\r\n};\n\n\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=input-shims-a4fc53ac-js-es2015.js.map","import { p as pointerCoord } from './helpers-46f4a262.js';\n\nconst cloneMap = new WeakMap();\r\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\r\n    if (cloneMap.has(componentEl) === shouldRelocate) {\r\n        return;\r\n    }\r\n    if (shouldRelocate) {\r\n        addClone(componentEl, inputEl, inputRelativeY);\r\n    }\r\n    else {\r\n        removeClone(componentEl, inputEl);\r\n    }\r\n};\r\nconst isFocused = (input) => {\r\n    return input === input.getRootNode().activeElement;\r\n};\r\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\r\n    // this allows for the actual input to receive the focus from\r\n    // the user's touch event, but before it receives focus, it\r\n    // moves the actual input to a location that will not screw\r\n    // up the app's layout, and does not allow the native browser\r\n    // to attempt to scroll the input into place (messing up headers/footers)\r\n    // the cloned input fills the area of where native input should be\r\n    // while the native input fakes out the browser by relocating itself\r\n    // before it receives the actual focus event\r\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\r\n    const parentEl = inputEl.parentNode;\r\n    // DOM WRITES\r\n    const clonedEl = inputEl.cloneNode(false);\r\n    clonedEl.classList.add('cloned-input');\r\n    clonedEl.tabIndex = -1;\r\n    parentEl.appendChild(clonedEl);\r\n    cloneMap.set(componentEl, clonedEl);\r\n    const doc = componentEl.ownerDocument;\r\n    const tx = doc.dir === 'rtl' ? 9999 : -9999;\r\n    componentEl.style.pointerEvents = 'none';\r\n    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\r\n};\r\nconst removeClone = (componentEl, inputEl) => {\r\n    const clone = cloneMap.get(componentEl);\r\n    if (clone) {\r\n        cloneMap.delete(componentEl);\r\n        clone.remove();\r\n    }\r\n    componentEl.style.pointerEvents = '';\r\n    inputEl.style.transform = '';\r\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\r\n    if (!scrollEl || !inputEl) {\r\n        return () => { return; };\r\n    }\r\n    const scrollHideCaret = (shouldHideCaret) => {\r\n        if (isFocused(inputEl)) {\r\n            relocateInput(componentEl, inputEl, shouldHideCaret);\r\n        }\r\n    };\r\n    const onBlur = () => relocateInput(componentEl, inputEl, false);\r\n    const hideCaret = () => scrollHideCaret(true);\r\n    const showCaret = () => scrollHideCaret(false);\r\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\r\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\r\n    inputEl.addEventListener('blur', onBlur);\r\n    return () => {\r\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\r\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\r\n        inputEl.addEventListener('ionBlur', onBlur);\r\n    };\r\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur]';\r\nconst enableInputBlurring = () => {\r\n    let focused = true;\r\n    let didScroll = false;\r\n    const doc = document;\r\n    const onScroll = () => {\r\n        didScroll = true;\r\n    };\r\n    const onFocusin = () => {\r\n        focused = true;\r\n    };\r\n    const onTouchend = (ev) => {\r\n        // if app did scroll return early\r\n        if (didScroll) {\r\n            didScroll = false;\r\n            return;\r\n        }\r\n        const active = doc.activeElement;\r\n        if (!active) {\r\n            return;\r\n        }\r\n        // only blur if the active element is a text-input or a textarea\r\n        if (active.matches(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        // if the selected target is the active element, do not blur\r\n        const tapped = ev.target;\r\n        if (tapped === active) {\r\n            return;\r\n        }\r\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        focused = false;\r\n        // TODO: find a better way, why 50ms?\r\n        setTimeout(() => {\r\n            if (!focused) {\r\n                active.blur();\r\n            }\r\n        }, 50);\r\n    };\r\n    doc.addEventListener('ionScrollStart', onScroll);\r\n    doc.addEventListener('focusin', onFocusin, true);\r\n    doc.addEventListener('touchend', onTouchend, false);\r\n    return () => {\r\n        doc.removeEventListener('ionScrollStart', onScroll, true);\r\n        doc.removeEventListener('focusin', onFocusin, true);\r\n        doc.removeEventListener('touchend', onTouchend, false);\r\n    };\r\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\r\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\r\n    const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\r\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\r\n};\r\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\r\n    // compute input's Y values relative to the body\r\n    const inputTop = inputRect.top;\r\n    const inputBottom = inputRect.bottom;\r\n    // compute visible area\r\n    const visibleAreaTop = contentRect.top;\r\n    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\r\n    // compute safe area\r\n    const safeAreaTop = visibleAreaTop + 15;\r\n    const safeAreaBottom = visibleAreaBottom * 0.5;\r\n    // figure out if each edge of the input is within the safe area\r\n    const distanceToBottom = safeAreaBottom - inputBottom;\r\n    const distanceToTop = safeAreaTop - inputTop;\r\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\r\n    const desiredScrollAmount = Math.round((distanceToBottom < 0)\r\n        ? -distanceToBottom\r\n        : (distanceToTop > 0)\r\n            ? -distanceToTop\r\n            : 0);\r\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\r\n    // gets focus, so make sure we don't scroll the input above the visible area\r\n    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\r\n    const distance = Math.abs(scrollAmount);\r\n    const duration = distance / SCROLL_ASSIST_SPEED;\r\n    const scrollDuration = Math.min(400, Math.max(150, duration));\r\n    return {\r\n        scrollAmount,\r\n        scrollDuration,\r\n        scrollPadding: keyboardHeight,\r\n        inputSafeY: -(inputTop - safeAreaTop) + 4\r\n    };\r\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, keyboardHeight) => {\r\n    let coord;\r\n    const touchStart = (ev) => {\r\n        coord = pointerCoord(ev);\r\n    };\r\n    const touchEnd = (ev) => {\r\n        // input cover touchend/mouseup\r\n        if (!coord) {\r\n            return;\r\n        }\r\n        // get where the touchend/mouseup ended\r\n        const endCoord = pointerCoord(ev);\r\n        // focus this input if the pointer hasn't moved XX pixels\r\n        // and the input doesn't already have focus\r\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            // begin the input focus process\r\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\r\n        }\r\n    };\r\n    componentEl.addEventListener('touchstart', touchStart, true);\r\n    componentEl.addEventListener('touchend', touchEnd, true);\r\n    return () => {\r\n        componentEl.removeEventListener('touchstart', touchStart, true);\r\n        componentEl.removeEventListener('touchend', touchEnd, true);\r\n    };\r\n};\r\nconst jsSetFocus = (componentEl, inputEl, contentEl, keyboardHeight) => {\r\n    const scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\r\n    if (Math.abs(scrollData.scrollAmount) < 4) {\r\n        // the text input is in a safe position that doesn't\r\n        // require it to be scrolled into view, just set focus now\r\n        inputEl.focus();\r\n        return;\r\n    }\r\n    // temporarily move the focus to the focus holder so the browser\r\n    // doesn't freak out while it's trying to get the input in place\r\n    // at this point the native text input still does not have focus\r\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\r\n    inputEl.focus();\r\n    // scroll the input into place\r\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(() => {\r\n        // the scroll view is in the correct position now\r\n        // give the native text input focus\r\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\r\n        // ensure this is the focused input\r\n        inputEl.focus();\r\n    });\r\n};\r\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\r\n    if (startCoord && endCoord) {\r\n        const deltaX = (startCoord.x - endCoord.x);\r\n        const deltaY = (startCoord.y - endCoord.y);\r\n        const distance = deltaX * deltaX + deltaY * deltaY;\r\n        return distance > (threshold * threshold);\r\n    }\r\n    return false;\r\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\r\nconst enableScrollPadding = (keyboardHeight) => {\r\n    const doc = document;\r\n    const onFocusin = (ev) => {\r\n        setScrollPadding(ev.target, keyboardHeight);\r\n    };\r\n    const onFocusout = (ev) => {\r\n        setScrollPadding(ev.target, 0);\r\n    };\r\n    doc.addEventListener('focusin', onFocusin);\r\n    doc.addEventListener('focusout', onFocusout);\r\n    return () => {\r\n        doc.removeEventListener('focusin', onFocusin);\r\n        doc.removeEventListener('focusout', onFocusout);\r\n    };\r\n};\r\nconst setScrollPadding = (input, keyboardHeight) => {\r\n    if (input.tagName !== 'INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement &&\r\n        input.parentElement.parentElement &&\r\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\r\n        return;\r\n    }\r\n    const el = input.closest('ion-content');\r\n    if (el === null) {\r\n        return;\r\n    }\r\n    const timer = el[PADDING_TIMER_KEY];\r\n    if (timer) {\r\n        clearTimeout(timer);\r\n    }\r\n    if (keyboardHeight > 0) {\r\n        el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\r\n    }\r\n    else {\r\n        el[PADDING_TIMER_KEY] = setTimeout(() => {\r\n            el.style.setProperty('--keyboard-offset', '0px');\r\n        }, 120);\r\n    }\r\n};\n\nconst INPUT_BLURRING = true;\r\nconst SCROLL_PADDING = true;\r\nconst startInputShims = (config) => {\r\n    const doc = document;\r\n    const keyboardHeight = config.getNumber('keyboardHeight', 290);\r\n    const scrollAssist = config.getBoolean('scrollAssist', true);\r\n    const hideCaret = config.getBoolean('hideCaretOnScroll', true);\r\n    const inputBlurring = config.getBoolean('inputBlurring', true);\r\n    const scrollPadding = config.getBoolean('scrollPadding', true);\r\n    const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\r\n    const hideCaretMap = new WeakMap();\r\n    const scrollAssistMap = new WeakMap();\r\n    const registerInput = (componentEl) => {\r\n        const inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\r\n        const scrollEl = componentEl.closest('ion-content');\r\n        if (!inputEl) {\r\n            return;\r\n        }\r\n        if ( !!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\r\n            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\r\n            hideCaretMap.set(componentEl, rmFn);\r\n        }\r\n        if ( !!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\r\n            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\r\n            scrollAssistMap.set(componentEl, rmFn);\r\n        }\r\n    };\r\n    const unregisterInput = (componentEl) => {\r\n        if ( hideCaret) {\r\n            const fn = hideCaretMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            hideCaretMap.delete(componentEl);\r\n        }\r\n        if ( scrollAssist) {\r\n            const fn = scrollAssistMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            scrollAssistMap.delete(componentEl);\r\n        }\r\n    };\r\n    if (inputBlurring && INPUT_BLURRING) {\r\n        enableInputBlurring();\r\n    }\r\n    if (scrollPadding && SCROLL_PADDING) {\r\n        enableScrollPadding(keyboardHeight);\r\n    }\r\n    // Input might be already loaded in the DOM before ion-device-hacks did.\r\n    // At this point we need to look for all of the inputs not registered yet\r\n    // and register them.\r\n    for (const input of inputs) {\r\n        registerInput(input);\r\n    }\r\n    doc.addEventListener('ionInputDidLoad', ((ev) => {\r\n        registerInput(ev.detail);\r\n    }));\r\n    doc.addEventListener('ionInputDidUnload', ((ev) => {\r\n        unregisterInput(ev.detail);\r\n    }));\r\n};\n\nexport { startInputShims };\n"]}