{"version":3,"sources":["index-69c37885-js-es5.js","webpack:///node_modules/@ionic/core/dist/esm/index-69c37885.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,mBAAmB,CAAC,EAAC;QAEpF,KAAK,CAAC,uDAAuD;QAC7D;;yEAEiE;QACjE,+BAA+B;QAC/B,KAAK,CAAC,CAAC,UAAS,MAAM,EAAE,mBAAmB,EAAE,mBAAmB;YAEhE,YAAY,CAAC;YCTb;YAAA;YAAA,IAAM,aAAa,GAAG,UAAC,EAAE,EAAE,QAAQ;gBAC/B,IAAI,UAAU,CAAC;gBACf,IAAM,IAAI,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;gBAC/B,IAAM,UAAU,GAAG;oBACf,IAAI,UAAU,EAAE;wBACZ,UAAU,EAAE,CAAC;qBAChB;gBACL,CAAC,CAAC;gBACF,IAAM,eAAe,GAAG,UAAC,EAAE;oBACvB,IAAI,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE;wBAClB,UAAU,EAAE,CAAC;wBACb,QAAQ,CAAC,EAAE,CAAC,CAAC;qBAChB;gBACL,CAAC,CAAC;gBACF,IAAI,EAAE,EAAE;oBACJ,EAAE,CAAC,gBAAgB,CAAC,qBAAqB,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;oBAClE,EAAE,CAAC,gBAAgB,CAAC,eAAe,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;oBAC5D,UAAU,GAAG;wBACT,EAAE,CAAC,mBAAmB,CAAC,qBAAqB,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;wBACrE,EAAE,CAAC,mBAAmB,CAAC,eAAe,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;oBACnE,CAAC,CAAC;iBACL;gBACD,OAAO,UAAU,CAAC;YACtB,CAAC,CAAC;YAEF,IAAM,eAAe,GAAG,oBAAoB,CAAC;YAC7C,IAAM,YAAY,GAAG,EAAE,CAAC;YACxB,IAAM,kCAAkC,GAAG,GAAG,CAAC;YAC/C,IAAM,eAAe,GAAG;gBACpB,YAAY,EAAE,CAAC;gBACf,YAAY,EAAE,CAAC;gBACf,YAAY,EAAE,CAAC;gBACf,OAAO,EAAE,CAAC;gBACV,QAAQ,EAAE,CAAC;gBACX,QAAQ,EAAE,CAAC;gBACX,QAAQ,EAAE,CAAC;gBACX,QAAQ,EAAE,CAAC;gBACX,SAAS,EAAE,CAAC;gBACZ,SAAS,EAAE,CAAC;gBACZ,SAAS,EAAE,CAAC;gBACZ,OAAO,EAAE,CAAC;gBACV,OAAO,EAAE,CAAC;gBACV,aAAa,EAAE,CAAC;aACnB,CAAC;YACF,IAAM,GAAG,GAAG,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;YACxD,IAAM,GAAG,GAAG,GAAG,CAAC,qBAAqB;gBACjC,CAAC,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC;gBACrC,CAAC,CAAC,UAAC,CAAC,IAAK,QAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAAb,CAAa,CAAC;YAC3B;gBACI;oBACI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;oBACrB,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;oBAC7B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;oBACtB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;oBACzB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC9B,CAAC;gBACD,6BAAU,GAAV,UAAW,EAAE;oBACT,IAAI,EAAE,IAAI,IAAI,EAAE;wBACZ,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE;4BACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gCAChC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;6BACtB;yBACJ;6BACI;4BACD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;yBACnB;qBACJ;oBACD,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,yBAAM,GAAN,UAAO,EAAE;oBACL,IAAI,EAAE,CAAC,QAAQ,KAAK,CAAC,EAAE;wBACnB,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;qBACpD;gBACL,CAAC;gBACD;;mBAEG;gBACH,sBAAG,GAAH,UAAI,cAAc;oBACd,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC;oBAC7B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;oBACxB,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAC3E,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,8BAAW,GAAX,UAAY,IAAI;oBACZ,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;wBACrC,OAAO,IAAI,CAAC,QAAQ,CAAC;qBACxB;yBACI,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;wBACnC,OAAO,IAAI,CAAC,SAAS,CAAC;qBACzB;yBACI,IAAI,IAAI,CAAC,MAAM,EAAE;wBAClB,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;qBACpC;oBACD,OAAO,CAAC,CAAC;gBACb,CAAC;gBACD;;mBAEG;gBACH,yBAAM,GAAN;oBACI,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;gBACxB,CAAC;gBACD;;mBAEG;gBACH,2BAAQ,GAAR,UAAS,YAAY;oBACjB,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC;oBAC9B,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,4BAAS,GAAT;oBACI,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,mBAAmB,KAAK,SAAS,EAAE;wBAC3D,OAAO,IAAI,CAAC,mBAAmB,CAAC;qBACnC;oBACD,OAAO,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,IAAI,IAAI,CAAC;gBAChH,CAAC;gBACD;;mBAEG;gBACH,yBAAM,GAAN,UAAO,IAAI;oBACP,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;oBACxB,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,gCAAa,GAAb,UAAc,IAAI;oBACd,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;oBAChC,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,uBAAI,GAAJ,UAAK,IAAI,EAAE,GAAG;oBACV,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;oBACjC,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,qBAAE,GAAF,UAAG,IAAI,EAAE,GAAG,EAAE,2BAAmC;oBAAnC,iFAAmC;oBAC7C,IAAM,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;oBAC1C,IAAI,2BAA2B,EAAE;wBAC7B,gEAAgE;wBAChE,2CAA2C;wBAC3C,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;qBACjF;oBACD,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,yBAAM,GAAN,UAAO,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,2BAA2B;oBACpD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,2BAA2B,CAAC,CAAC;gBACjF,CAAC;gBACD;;mBAEG;gBACH,2BAAQ,GAAR,UAAS,IAAI;oBACT,IAAI,IAAI,CAAC,aAAa,EAAE;wBACpB,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,cAAI,IAAI,WAAI,CAAC,UAAU,KAAK,IAAI,EAAxB,CAAwB,CAAC,CAAC;qBACpE;oBACD,OAAO,SAAS,CAAC;gBACrB,CAAC;gBACD,2BAAQ,GAAR,UAAS,KAAK,EAAE,IAAI,EAAE,GAAG;oBACrB,IAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;oBACjC,IAAI,CAAC,MAAM,EAAE;wBACT,2CAA2C;wBAC3C,IAAM,WAAW,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;wBAClD,MAAM,GAAG;4BACL,UAAU,EAAE,IAAI;4BAChB,KAAK,EAAE,WAAW;4BAClB,yDAAyD;4BACzD,EAAE,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC;yBACzC,CAAC;wBACF,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;qBAChE;oBACD,gDAAgD;oBAChD,IAAM,OAAO,GAAG;wBACZ,GAAG;wBACH,GAAG,EAAE,CAAC;wBACN,UAAU,EAAE,EAAE;qBACjB,CAAC;oBACF,MAAM,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC;oBACxB,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;wBACjD,IAAM,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;wBACrC,IAAI,CAAC,EAAE;4BACH,IAAM,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BAC7B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gCACb,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;6BACrB;4BACD,OAAO,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;yBACpD;qBACJ;yBACI,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;wBAC9B,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;qBACrB;oBACD,OAAO,MAAM,CAAC;gBAClB,CAAC;gBACD;;;mBAGG;gBACH,iCAAc,GAAd,UAAe,SAAS;oBACpB,CAAC,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBACxE,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,oCAAiB,GAAjB,UAAkB,SAAS;oBACvB,CAAC,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAC9E,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,+BAAY,GAAZ,UAAa,MAAM;oBACf,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC;oBAC5B,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,oCAAiB,GAAjB,UAAkB,aAAa;;oBAC3B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC;;wBAC9C,KAAmB,4CAAa,oHAAE;4BAA7B,IAAM,IAAI;4BACX,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;yBACjC;;;;;;;;;oBACD,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,gCAAa,GAAb,UAAc,SAAS;oBACnB,CAAC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAClE,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,iCAAc,GAAd,UAAe,UAAU;oBACrB,CAAC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;oBACrE,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,gCAAa,GAAb,UAAc,SAAS;oBACnB,CAAC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBACtE,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,mCAAgB,GAAhB,UAAiB,SAAS;oBACtB,CAAC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAC5E,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,8BAAW,GAAX,UAAY,MAAM;oBACd,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;oBAC3B,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,mCAAgB,GAAhB,UAAiB,aAAa;;oBAC1B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,EAAE,CAAC;;wBAC5C,KAAmB,4CAAa,oHAAE;4BAA7B,IAAM,IAAI;4BACX,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;yBAChC;;;;;;;;;oBACD,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,uBAAI,GAAJ,UAAK,IAAI;oBAAT,iBA0BC;oBAzBG,uEAAuE;oBACvE,IAAI,IAAI,CAAC,UAAU,EAAE;wBACjB,OAAO;qBACV;oBACD,yDAAyD;oBACzD,oDAAoD;oBACpD,qEAAqE;oBACrE,iEAAiE;oBACjE,iEAAiE;oBACjE,uEAAuE;oBACvE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;oBACxC,0DAA0D;oBAC1D,IAAI,CAAC,WAAW,EAAE,CAAC;oBACnB,2EAA2E;oBAC3E,sCAAsC;oBACtC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBACrB,+DAA+D;oBAC/D,oEAAoE;oBACpE,mEAAmE;oBACnE,mEAAmE;oBACnE,GAAG,CAAC;wBACA,GAAG,CAAC;4BACA,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;wBAC/B,CAAC,CAAC,CAAC;oBACP,CAAC,CAAC,CAAC;gBACP,CAAC;gBACD,4BAAS,GAAT,UAAU,IAAI;oBAAd,iBAMC;oBALG,OAAO,IAAI,OAAO,CAAC,iBAAO;wBACtB,KAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,sBAAsB,EAAE,IAAI,EAAE,CAAC,CAAC;wBAChF,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAChB,OAAO,KAAI,CAAC;oBAChB,CAAC,CAAC,CAAC;gBACP,CAAC;gBACD,2BAAQ,GAAR;oBACI,uEAAuE;oBACvE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;wBAClB,IAAM,IAAI,GAAG,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC;wBAC7B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;wBACtB,IAAI,CAAC,WAAW,EAAE,CAAC;wBACnB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;wBACrB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;qBAC9B;gBACL,CAAC;gBACD;;;mBAGG;gBACH,4BAAS,GAAT,UAAU,IAAI;;oBACV,kDAAkD;oBAClD,0DAA0D;oBAC1D,8CAA8C;oBAC9C,uDAAuD;oBACvD,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;oBAC7B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;oBACtB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;oBAC1B,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,CAAC;oBACvD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;6BACzB;;;;;;;;;qBACJ;oBACD,IAAI,IAAI,CAAC,OAAO,EAAE;wBACd,yDAAyD;wBACzD,sCAAsC;wBACtC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;wBAClB,iCAAiC;wBACjC,sCAAsC;wBACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;qBAC1B;gBACL,CAAC;gBACD;;;;mBAIG;gBACH,kCAAe,GAAf,UAAgB,IAAI;oBAApB,iBAuBC;oBAtBG,iEAAiE;oBACjE,uDAAuD;oBACvD,6CAA6C;oBAC7C,qCAAqC;oBACrC,sCAAsC;oBACtC,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,8BAA8B;oBAC9B,qCAAqC;oBACrC,8CAA8C;oBAC9C,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;oBACnC,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;qBAC7B;oBACD,sCAAsC;oBACtC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;oBACzB,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;wBACnC,uDAAuD;wBACvD,+CAA+C;wBAC/C,GAAG,CAAC;4BACA,KAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;wBACxB,CAAC,CAAC,CAAC;qBACN;gBACL,CAAC;gBACD;;;mBAGG;gBACH,gCAAa,GAAb,UAAc,IAAI;;oBACd,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;6BAC7B;;;;;;;;;qBACJ;oBACD,IAAI,IAAI,CAAC,OAAO,EAAE;wBACd,yCAAyC;wBACzC,sCAAsC;wBACtC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;qBACjD;yBACI;wBACD,oEAAoE;wBACpE,yDAAyD;wBACzD,sCAAsC;wBACtC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;wBAClB,0DAA0D;wBAC1D,sCAAsC;wBACtC,IAAI,CAAC,eAAe,EAAE,CAAC;wBACvB,qDAAqD;wBACrD,0CAA0C;wBAC1C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;qBACzB;gBACL,CAAC;gBACD;;;mBAGG;gBACH,8BAAW,GAAX,UAAY,SAAS;;oBACjB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;wBAClB,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;wBACvC,IAAI,QAAQ,EAAE;;gCACV,KAAoB,kCAAQ,2FAAE;oCAAzB,IAAM,KAAK;oCACZ,sCAAsC;oCACtC,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;iCAChC;;;;;;;;;yBACJ;wBACD,IAAI,IAAI,CAAC,OAAO,EAAE;4BACd,sDAAsD;4BACtD,4CAA4C;4BAC5C,uEAAuE;4BACvE,sCAAsC;4BACtC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;yBAC7B;qBACJ;gBACL,CAAC;gBACD;;;;mBAIG;gBACH,4BAAS,GAAT,UAAU,GAAG,EAAE,cAAc;oBACzB,IAAM,IAAI,GAAG,IAAI,CAAC;oBAClB,IAAM,eAAe,GAAG;wBACpB,+CAA+C;wBAC/C,8DAA8D;wBAC9D,IAAI,CAAC,WAAW,EAAE,CAAC;wBACnB,sCAAsC;wBACtC,IAAI,CAAC,QAAQ,EAAE,CAAC;wBAChB,sBAAsB;wBACtB,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;oBACpD,CAAC,CAAC;oBACF,IAAM,oBAAoB,GAAG;wBACzB,wDAAwD;wBACxD,wCAAwC;wBACxC,mDAAmD;wBACnD,+CAA+C;wBAC/C,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;wBAC1B,IAAI,CAAC,WAAW,EAAE,CAAC;wBACnB,uBAAuB;wBACvB,sCAAsC;wBACtC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtC,sBAAsB;wBACtB,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;oBACpD,CAAC,CAAC;oBACF,iEAAiE;oBACjE,IAAI,CAAC,kBAAkB,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,eAAe,CAAC,CAAC;oBAC1E,iFAAiF;oBACjF,uDAAuD;oBACvD,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC,oBAAoB,EAAE,CAAC,GAAG,GAAG,kCAAkC,CAAC,CAAC,CAAC;gBACjG,CAAC;gBACD;;;mBAGG;gBACH,2BAAQ,GAAR,UAAS,SAAS;;oBACd,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;6BAC7B;;;;;;;;;qBACJ;oBACD,IAAI,IAAI,CAAC,OAAO,EAAE;wBACd,IAAI,SAAS,KAAK,SAAS,EAAE;4BACzB,sDAAsD;4BACtD,sCAAsC;4BACtC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;4BACxB,gDAAgD;4BAChD,sCAAsC;4BACtC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;yBAC7B;wBACD,uBAAuB;wBACvB,sCAAsC;wBACtC,IAAI,CAAC,eAAe,EAAE,CAAC;wBACvB,oCAAoC;wBACpC,sCAAsC;wBACtC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;qBAC3B;gBACL,CAAC;gBACD;;;mBAGG;gBACH,+BAAY,GAAZ,UAAa,IAAI;;oBACb,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,YAAY,EAAE;wBACvC,OAAO,IAAI,CAAC;qBACf;oBACD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,IAAI,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;oCAC1B,OAAO,IAAI,CAAC;iCACf;6BACJ;;;;;;;;;qBACJ;oBACD,OAAO,KAAK,CAAC;gBACjB,CAAC;gBACD;;;mBAGG;gBACH,+BAAY,GAAZ;;oBACI,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;wBACvD,OAAO,IAAI,CAAC;qBACf;oBACD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,IAAI,KAAK,CAAC,YAAY,EAAE,EAAE;oCACtB,OAAO,IAAI,CAAC;iCACf;6BACJ;;;;;;;;;qBACJ;oBACD,OAAO,KAAK,CAAC;gBACjB,CAAC;gBACD;;mBAEG;gBACH,uBAAI,GAAJ,UAAK,SAAa;oBAAb,yCAAa;oBACd,0DAA0D;oBAC1D,IAAI,CAAC,WAAW,EAAE,CAAC;oBACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;oBACpB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;gBAC7B,CAAC;gBACD;;;mBAGG;gBACH,8BAAW,GAAX;oBACI,IAAI,IAAI,CAAC,kBAAkB,EAAE;wBACzB,IAAI,CAAC,kBAAkB,EAAE,CAAC;qBAC7B;oBACD,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;qBAC/B;oBACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC;gBACxD,CAAC;gBACD;;;mBAGG;gBACH,4BAAS,GAAT,UAAU,SAAS;oBACf,kBAAkB;oBAClB,IAAI,GAAG,CAAC;oBACR,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;oBAChC,IAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;oBACnC,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE;wBACnE,OAAO;qBACV;oBACD,4CAA4C;oBAC5C,IAAI,IAAI,CAAC,UAAU,EAAE;wBACjB,SAAS,GAAG,CAAC,GAAG,SAAS,CAAC;qBAC7B;oBACD,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,IAAI,cAAc,GAAG,EAAE,CAAC;oBACxB,IAAI,EAAE,CAAC;oBACP,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBACjC,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;wBAChB,IAAI,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;4BAClB,IAAM,OAAO,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC;4BAC5B,IAAM,KAAK,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;4BACxB,IAAM,WAAW,GAAG,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC;4BACxC,IAAI,WAAW,EAAE;gCACb,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;6BAC/B;4BACD,IAAI,SAAS,KAAK,CAAC,EAAE;gCACjB,OAAO;gCACP,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC;6BACrB;iCACI,IAAI,SAAS,KAAK,CAAC,EAAE;gCACtB,KAAK;gCACL,GAAG,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;6BACnB;iCACI,IAAI,WAAW,EAAE;gCAClB,wBAAwB;gCACxB,IAAM,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG,OAAO,CAAC,CAAC;gCAC3D,IAAM,IAAI,GAAG,EAAE,CAAC,EAAE,CAAC,UAAU,CAAC;gCAC9B,GAAG,GAAG,MAAM,GAAG,IAAI,CAAC;6BACvB;4BACD,IAAI,GAAG,KAAK,IAAI,EAAE;gCACd,IAAM,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC;gCAC3B,IAAI,EAAE,CAAC,KAAK,EAAE;oCACV,cAAc,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC;iCAC7C;qCACI;oCACD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wCAClC,sCAAsC;wCACtC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;qCAC5C;iCACJ;6BACJ;yBACJ;qBACJ;oBACD,4CAA4C;oBAC5C,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC3B,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,SAAS,KAAK,CAAC,IAAI,IAAI,CAAC,UAAU,IAAI,SAAS,KAAK,CAAC,EAAE;4BAC3E,cAAc,IAAI,iBAAiB,CAAC;yBACvC;wBACD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BAClC,sCAAsC;4BACtC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;4BAC3D,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC;yBACtE;qBACJ;gBACL,CAAC;gBACD;;;mBAGG;gBACH,4BAAS,GAAT,UAAU,GAAG,EAAE,kBAAkB;;oBAC7B,qDAAqD;oBACrD,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;oBAChC,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;wBAC3D,OAAO;qBACV;oBACD,sDAAsD;oBACtD,IAAM,MAAM,GAAG,CAAC,kBAAkB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;oBAClE,IAAM,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC;;wBAC7B,KAAwB,kCAAQ,2FAAE;4BAArB,oCAAK;4BACd,IAAI,GAAG,GAAG,CAAC,EAAE;gCACT,sCAAsC;gCACtC,KAAK,CAAC,kBAAkB,GAAG,SAAS,CAAC;gCACrC,6CAA6C;gCAC7C,IAAI,MAAM,KAAK,IAAI,EAAE;oCACjB,sCAAsC;oCACtC,KAAK,CAAC,wBAAwB,GAAG,MAAM,CAAC;iCAC3C;6BACJ;iCACI;gCACD,KAAK,CAAC,kBAAkB,GAAG,GAAG,CAAC;6BAClC;yBACJ;;;;;;;;;gBACL,CAAC;gBACD;;;;mBAIG;gBACH,mCAAgB,GAAhB;oBACI,iEAAiE;oBACjE,uDAAuD;oBACvD,6CAA6C;oBAC7C,qCAAqC;oBACrC,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC3B,+DAA+D;oBAC/D,kEAAkE;oBAClE,sCAAsC;oBACtC,IAAI,CAAC,oBAAoB,EAAE,CAAC;oBAC5B,wDAAwD;oBACxD,sCAAsC;oBACtC,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBAC5B,CAAC;gBACD;;;mBAGG;gBACH,mCAAgB,GAAhB;;oBACI,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,KAAK,CAAC,gBAAgB,EAAE,CAAC;6BAC5B;;;;;;;;;qBACJ;oBACD,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;oBAChC,qCAAqC;oBACrC,sDAAsD;oBACtD,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,UAAU,EAAE;wBACvD,OAAO;qBACV;oBACD,IAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC;oBAC1C,IAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC;;wBAChD,KAAiB,kCAAQ,2FAAE;4BAAtB,IAAM,EAAE;4BACT,IAAM,gBAAgB,GAAG,EAAE,CAAC,SAAS,CAAC;4BACtC,0CAA0C;4BAC1C,IAAI,UAAU,EAAE;;oCACZ,KAAgB,sDAAU,sGAAE;wCAAvB,IAAM,CAAC;wCACR,sCAAsC;wCACtC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;qCAC3B;;;;;;;;;6BACJ;4BACD,6CAA6C;4BAC7C,IAAI,aAAa,EAAE;;oCACf,KAAgB,4DAAa,qHAAE;wCAA1B,IAAM,CAAC;wCACR,sCAAsC;wCACtC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;qCAC9B;;;;;;;;;6BACJ;4BACD,4CAA4C;4BAC5C,IAAI,IAAI,CAAC,aAAa,EAAE;;oCACpB,KAA2B,wCAAM,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,8CAAE;wCAApD,4BAAY,EAAX,WAAG,EAAE,aAAK;wCAClB,sCAAsC;wCACtC,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;qCACpC;;;;;;;;;6BACJ;yBACJ;;;;;;;;;gBACL,CAAC;gBACD;;;mBAGG;gBACH,sCAAmB,GAAnB;;oBACI,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,qCAAqC;gCACrC,KAAK,CAAC,mBAAmB,EAAE,CAAC;6BAC/B;;;;;;;;;qBACJ;oBACD,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC;oBAC1C,IAAI,aAAa,EAAE;;4BACf,KAAuB,4CAAa,oHAAE;gCAAjC,IAAM,QAAQ;gCACf,qCAAqC;gCACrC,QAAQ,EAAE,CAAC;6BACd;;;;;;;;;qBACJ;gBACL,CAAC;gBACD;;;mBAGG;gBACH,uCAAoB,GAApB;;oBACI,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,kCAAQ,2FAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,oBAAoB,EAAE,CAAC;6BAChC;;;;;;;;;qBACJ;oBACD,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC;oBAC5C,IAAI,cAAc,EAAE;;4BAChB,KAAuB,8CAAc,yHAAE;gCAAlC,IAAM,QAAQ;gCACf,sCAAsC;gCACtC,QAAQ,EAAE,CAAC;6BACd;;;;;;;;;qBACJ;gBACL,CAAC;gBACD;;mBAEG;gBACH,kCAAe,GAAf;;oBACI,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;oBAChC,IAAI,CAAC,QAAQ,EAAE;wBACX,OAAO;qBACV;;wBACD,KAAiB,kCAAQ,2FAAE;4BAAtB,IAAM,EAAE;4BACT,IAAM,gBAAgB,GAAG,EAAE,CAAC,SAAS,CAAC;4BACtC,wCAAwC;4BACxC,sCAAsC;4BACtC,EAAE,CAAC,KAAK,CAAC,kBAAkB,GAAG,EAAE,CAAC,KAAK,CAAC,wBAAwB,GAAG,EAAE,CAAC;4BACrE,IAAI,IAAI,CAAC,UAAU,EAAE;gCACjB,gCAAgC;gCAChC,qEAAqE;gCACrE,IAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC;gCAChD,IAAI,gBAAgB,EAAE;;wCAClB,KAAgB,kEAAgB,oIAAE;4CAA7B,IAAM,CAAC;4CACR,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;yCAC9B;;;;;;;;;iCACJ;gCACD,qEAAqE;gCACrE,IAAM,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC;gCACtD,IAAI,mBAAmB,EAAE;;wCACrB,KAAgB,wEAAmB,mJAAE;4CAAhC,IAAM,CAAC;4CACR,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;yCAC3B;;;;;;;;;iCACJ;gCACD,uEAAuE;gCACvE,IAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;gCACxC,IAAI,YAAY,EAAE;;wCACd,KAAuB,wCAAM,CAAC,IAAI,CAAC,YAAY,CAAC,8CAAE;4CAA7C,IAAM,QAAQ;4CACf,sCAAsC;4CACtC,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;yCACrC;;;;;;;;;iCACJ;6BACJ;iCACI;gCACD,gCAAgC;gCAChC,yCAAyC;gCACzC,IAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC;gCAC9C,IAAI,eAAe,EAAE;;wCACjB,KAAgB,gEAAe,+HAAE;4CAA5B,IAAM,CAAC;4CACR,sCAAsC;4CACtC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;yCAC3B;;;;;;;;;iCACJ;gCACD,4CAA4C;gCAC5C,IAAM,kBAAkB,GAAG,IAAI,CAAC,mBAAmB,CAAC;gCACpD,IAAI,kBAAkB,EAAE;;wCACpB,KAAgB,sEAAkB,8IAAE;4CAA/B,IAAM,CAAC;4CACR,sCAAsC;4CACtC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;yCAC9B;;;;;;;;;iCACJ;gCACD,2CAA2C;gCAC3C,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;gCACtC,IAAI,WAAW,EAAE;;wCACb,KAA2B,wCAAM,CAAC,OAAO,CAAC,WAAW,CAAC,8CAAE;4CAA7C,4BAAY,EAAX,WAAG,EAAE,aAAK;4CAClB,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;yCACpC;;;;;;;;;iCACJ;6BACJ;yBACJ;;;;;;;;;gBACL,CAAC;gBACD;;;mBAGG;gBACH,8BAAW,GAAX,UAAY,aAAa;;oBACrB,IAAI,EAAE,CAAC;oBACP,IAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;oBACnC,IAAI,UAAU,CAAC;oBACf,IAAI,aAAa,IAAI,OAAO,EAAE;wBAC1B,EAAE,GAAG,EAAE,CAAC;;4BACR,KAAqB,gCAAO,sFAAE;gCAAzB,IAAM,MAAM;gCACb,IAAM,MAAM,GAAG,MAAM,CAAC,EAAE,CAAC;gCACzB,IAAI,MAAM,KAAK,iBAAiB,EAAE;oCAC9B,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,mBAAmB,CAAC,CAAC;iCAC7C;qCACI,IAAI,MAAM,KAAK,SAAS,EAAE;oCAC3B,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iCACnB;6BACJ;;;;;;;;;wBACD,UAAU,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;qBAC7B;yBACI;wBACD,UAAU,GAAG,EAAE,CAAC;qBACnB;oBACD,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;oBAChC,IAAI,QAAQ,EAAE;;4BACV,KAAiB,kCAAQ,2FAAE;gCAAtB,IAAM,EAAE;gCACT,sCAAsC;gCACtC,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;6BACnD;;;;;;;;;qBACJ;gBACL,CAAC;gBACD;;mBAEG;gBACH,gCAAa,GAAb;oBACI,0DAA0D;oBAC1D,IAAI,CAAC,WAAW,EAAE,CAAC;oBACnB,2CAA2C;oBAC3C,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,sCAAsC;oBACtC,IAAI,CAAC,cAAc,EAAE,CAAC;gBAC1B,CAAC;gBACD;;;mBAGG;gBACH,iCAAc,GAAd;;oBACI,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,cAAc,EAAE,CAAC;6BAC1B;;;;;;;;;qBACJ;oBACD,mCAAmC;oBACnC,sCAAsC;oBACtC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;oBACxB,sCAAsC;oBACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC;gBACD;;;mBAGG;gBACH,+BAAY,GAAZ,UAAa,SAAS;;oBAClB,wDAAwD;oBACxD,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC;oBAChD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;6BACjC;;;;;;;;;qBACJ;oBACD,sCAAsC;oBACtC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;gBAC9B,CAAC;gBACD;;mBAEG;gBACH,8BAAW,GAAX,UAAY,cAAc,EAAE,gBAAgB,EAAE,GAAQ;oBAAtD,iBA8BC;oBA9B6C,6BAAO,CAAC;oBAClD,IAAI,IAAI,CAAC,UAAU,EAAE;wBACjB,4CAA4C;wBAC5C,gDAAgD;wBAChD,gBAAgB,GAAG,CAAC,GAAG,gBAAgB,CAAC;qBAC3C;oBACD,IAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACzC,IAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,GAAG,SAAS,CAAC,CAAC;oBACpD,IAAI,GAAG,GAAG,CAAC,EAAE;wBACT,GAAG,GAAG,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC;qBAC7B;yBACI,IAAI,IAAI,GAAG,IAAI,EAAE;wBAClB,GAAG,GAAG,CAAC,CAAC;qBACX;oBACD,IAAI,CAAC,QAAQ,GAAG,CAAC,GAAG,GAAG,EAAE,CAAC,CAAC;oBAC3B,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACjE,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,8BAA8B;wBAC9B,qCAAqC;wBACrC,8CAA8C;wBAC9C,sCAAsC;wBACtC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;wBACpC,uDAAuD;wBACvD,+CAA+C;wBAC/C,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;4BAClB,GAAG,CAAC;gCACA,KAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;4BAChC,CAAC,CAAC,CAAC;yBACN;qBACJ;gBACL,CAAC;gBACD;;;mBAGG;gBACH,+BAAY,GAAZ,UAAa,cAAc,EAAE,SAAS,EAAE,GAAG,EAAE,OAAO;;oBAChD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,sCAAsC;gCACtC,KAAK,CAAC,YAAY,CAAC,cAAc,EAAE,SAAS,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;6BAC/D;;;;;;;;;qBACJ;oBACD,IAAI,CAAC,OAAO,EAAE;wBACV,mBAAmB;wBACnB,iDAAiD;wBACjD,sCAAsC;wBACtC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;wBAC1B,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;wBACxB,IAAI,CAAC,eAAe,EAAE,CAAC;wBACvB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;qBACnC;yBACI;wBACD,0CAA0C;wBAC1C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;wBAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;wBACpB,sCAAsC;wBACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;wBACvB,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;qBAC9B;gBACL,CAAC;gBACD;;mBAEG;gBACH,2BAAQ,GAAR,UAAS,QAAQ,EAAE,IAAI;oBACnB,IAAI,IAAI,IAAI,IAAI,CAAC,sBAAsB,EAAE;wBACrC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,yBAAyB,GAAG,SAAS,CAAC;qBACxE;oBACD,IAAI,IAAI,IAAI,IAAI,CAAC,eAAe,EAAE;wBAC9B,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,yBAAyB,IAAI,EAAE,CAAC;wBACtE,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;qBACjD;yBACI;wBACD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,IAAI,EAAE,CAAC;wBACxD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;qBAC1C;oBACD,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;;mBAGG;gBACH,gCAAa,GAAb,UAAc,YAAY,EAAE,qBAAqB,EAAE,0BAA0B;;oBACzE,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,KAAK,CAAC,aAAa,CAAC,YAAY,EAAE,qBAAqB,EAAE,0BAA0B,CAAC,CAAC;6BACxF;;;;;;;;;qBACJ;oBACD,IAAI,qBAAqB,IAAI,IAAI,CAAC,QAAQ,IAAI,0BAA0B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;wBACxF,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;qBACjC;gBACL,CAAC;gBACD;;mBAEG;gBACH,6BAAU,GAAV,UAAW,YAAY;;oBACnB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;oBACvB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;oBACjC,IAAI,IAAI,CAAC,kBAAkB,EAAE;;4BACzB,2BAA2B;4BAC3B,KAAuB,sBAAI,CAAC,kBAAkB,6CAAE;gCAA3C,IAAM,QAAQ;gCACf,QAAQ,CAAC,IAAI,CAAC,CAAC;6BAClB;;;;;;;;;qBACJ;oBACD,IAAI,IAAI,CAAC,yBAAyB,EAAE;;4BAChC,qCAAqC;4BACrC,KAAuB,sBAAI,CAAC,yBAAyB,6CAAE;gCAAlD,IAAM,QAAQ;gCACf,QAAQ,CAAC,IAAI,CAAC,CAAC;6BAClB;;;;;;;;;wBACD,IAAI,CAAC,yBAAyB,CAAC,MAAM,GAAG,CAAC,CAAC;qBAC7C;gBACL,CAAC;gBACD;;mBAEG;gBACH,0BAAO,GAAP,UAAQ,aAAoB;;oBAApB,oDAAoB;oBACxB,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;6BAChC;;;;;;;;;qBACJ;oBACD,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,aAAa,CAAC;oBAClC,OAAO,IAAI,CAAC;gBAChB,CAAC;gBACD;;mBAEG;gBACH,0BAAO,GAAP;;oBACI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;oBACvB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;oBACvB,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,KAAK,CAAC,OAAO,EAAE,CAAC;6BACnB;;;;;;;;;qBACJ;oBACD,IAAI,CAAC,WAAW,EAAE,CAAC;oBACnB,IAAI,IAAI,CAAC,SAAS,EAAE;wBAChB,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;qBAC7B;oBACD,IAAI,IAAI,CAAC,cAAc,EAAE;wBACrB,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;qBAClC;oBACD,IAAI,IAAI,CAAC,eAAe,EAAE;wBACtB,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;qBACnC;oBACD,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;oBACxB,IAAI,IAAI,CAAC,gBAAgB,EAAE;wBACvB,IAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;qBACpC;oBACD,IAAI,IAAI,CAAC,kBAAkB,EAAE;wBACzB,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;qBACtC;oBACD,IAAI,IAAI,CAAC,yBAAyB,EAAE;wBAChC,IAAI,CAAC,yBAAyB,CAAC,MAAM,GAAG,CAAC,CAAC;qBAC7C;gBACL,CAAC;gBACD;;mBAEG;gBACH,2BAAQ,GAAR;;oBACI,oDAAoD;oBACpD,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACvC,IAAI,QAAQ,EAAE;;4BACV,KAAoB,mCAAQ,gGAAE;gCAAzB,IAAM,KAAK;gCACZ,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;gCAClC,IAAI,QAAQ,EAAE;oCACV,OAAO,QAAQ,CAAC;iCACnB;6BACJ;;;;;;;;;qBACJ;oBACD,OAAO,CAAC,IAAI,CAAC,eAAe;wBACxB,IAAI,CAAC,OAAO;wBACZ,IAAI,CAAC,SAAS,KAAK,SAAS;wBAC5B,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBAC3B,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBAClC,CAAC;gBACL,eAAC;YAAD,CAAC;YAED,IAAM,MAAM,GAAG,UAAC,gBAAgB,EAAE,MAAM,EAAE,IAAI;gBAC1C,IAAI,gBAAgB,EAAE;oBAClB,OAAO,gBAAgB,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;iBACnD;gBACD,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,QAAQ,EAAE,CAAC,CAAC;YAC3C,CAAC,CAAC;YDiBF,KAAK;QAAC,CAAC,CAAC;KAEP,CAAC,CAAC,CAAC;AACJ,oDAAoD","file":"x","sourcesContent":["(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"index-69c37885-js\"],{\n\n/***/ \"./node_modules/@ionic/core/dist/esm/index-69c37885.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/@ionic/core/dist/esm/index-69c37885.js ***!\n  \\*************************************************************/\n/*! exports provided: create */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\nconst transitionEnd = (el, callback) => {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    const unregister = () => {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    };\r\n    const onTransitionEnd = (ev) => {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    };\r\n    if (el) {\r\n        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n        el.addEventListener('transitionend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('transitionend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n};\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\r\nconst DURATION_MIN = 32;\r\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\r\nconst TRANSFORM_PROPS = {\r\n    'translateX': 1,\r\n    'translateY': 1,\r\n    'translateZ': 1,\r\n    'scale': 1,\r\n    'scaleX': 1,\r\n    'scaleY': 1,\r\n    'scaleZ': 1,\r\n    'rotate': 1,\r\n    'rotateX': 1,\r\n    'rotateY': 1,\r\n    'rotateZ': 1,\r\n    'skewX': 1,\r\n    'skewY': 1,\r\n    'perspective': 1\r\n};\r\nconst win = typeof window !== 'undefined' ? window : {};\r\nconst raf = win.requestAnimationFrame\r\n    ? win.requestAnimationFrame.bind(win)\r\n    : (f) => f(Date.now());\r\nclass Animator {\r\n    constructor() {\r\n        this._hasDur = false;\r\n        this._hasTweenEffect = false;\r\n        this._isAsync = false;\r\n        this._isReverse = false;\r\n        this._destroyed = false;\r\n        this.hasChildren = false;\r\n        this.isPlaying = false;\r\n        this.hasCompleted = false;\r\n    }\r\n    addElement(el) {\r\n        if (el != null) {\r\n            if (el.length > 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    this._addEl(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                this._addEl(el);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _addEl(el) {\r\n        if (el.nodeType === 1) {\r\n            (this._elements = this._elements || []).push(el);\r\n        }\r\n    }\r\n    /**\r\n     * Add a child animation to this animation.\r\n     */\r\n    add(childAnimation) {\r\n        childAnimation.parent = this;\r\n        this.hasChildren = true;\r\n        (this._childAnimations = this._childAnimations || []).push(childAnimation);\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the duration of this animation. If this animation does\r\n     * not have a duration, then it'll get the duration from its parent.\r\n     */\r\n    getDuration(opts) {\r\n        if (opts && opts.duration !== undefined) {\r\n            return opts.duration;\r\n        }\r\n        else if (this._duration !== undefined) {\r\n            return this._duration;\r\n        }\r\n        else if (this.parent) {\r\n            return this.parent.getDuration();\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Returns if the animation is a root one.\r\n     */\r\n    isRoot() {\r\n        return !this.parent;\r\n    }\r\n    /**\r\n     * Set the duration for this animation.\r\n     */\r\n    duration(milliseconds) {\r\n        this._duration = milliseconds;\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the easing of this animation. If this animation does\r\n     * not have an easing, then it'll get the easing from its parent.\r\n     */\r\n    getEasing() {\r\n        if (this._isReverse && this._reversedEasingName !== undefined) {\r\n            return this._reversedEasingName;\r\n        }\r\n        return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\r\n    }\r\n    /**\r\n     * Set the easing for this animation.\r\n     */\r\n    easing(name) {\r\n        this._easingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Set the easing for this reversed animation.\r\n     */\r\n    easingReverse(name) {\r\n        this._reversedEasingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"from\" value for a specific property.\r\n     */\r\n    from(prop, val) {\r\n        this._addProp('from', prop, val);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"to\" value for a specific property.\r\n     */\r\n    to(prop, val, clearProperyAfterTransition = false) {\r\n        const fx = this._addProp('to', prop, val);\r\n        if (clearProperyAfterTransition) {\r\n            // if this effect is a transform then clear the transform effect\r\n            // otherwise just clear the actual property\r\n            this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Shortcut to add both the \"from\" and \"to\" for the same property.\r\n     */\r\n    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\r\n        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _getProp(name) {\r\n        if (this._fxProperties) {\r\n            return this._fxProperties.find(prop => prop.effectName === name);\r\n        }\r\n        return undefined;\r\n    }\r\n    _addProp(state, prop, val) {\r\n        let fxProp = this._getProp(prop);\r\n        if (!fxProp) {\r\n            // first time we've see this EffectProperty\r\n            const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\r\n            fxProp = {\r\n                effectName: prop,\r\n                trans: shouldTrans,\r\n                // add the will-change property for transforms or opacity\r\n                wc: (shouldTrans ? 'transform' : prop)\r\n            };\r\n            (this._fxProperties = this._fxProperties || []).push(fxProp);\r\n        }\r\n        // add from/to EffectState to the EffectProperty\r\n        const fxState = {\r\n            val,\r\n            num: 0,\r\n            effectUnit: '',\r\n        };\r\n        fxProp[state] = fxState;\r\n        if (typeof val === 'string' && val.indexOf(' ') < 0) {\r\n            const r = val.match(CSS_VALUE_REGEX);\r\n            if (r) {\r\n                const num = parseFloat(r[1]);\r\n                if (!isNaN(num)) {\r\n                    fxState.num = num;\r\n                }\r\n                fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\r\n            }\r\n        }\r\n        else if (typeof val === 'number') {\r\n            fxState.num = val;\r\n        }\r\n        return fxProp;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeAddClass(className) {\r\n        (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeRemoveClass(className) {\r\n        (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeStyles(styles) {\r\n        this._beforeStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeClearStyles(propertyNames) {\r\n        this._beforeStyles = this._beforeStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._beforeStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM reads, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddRead(domReadFn) {\r\n        (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM writes, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddWrite(domWriteFn) {\r\n        (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterAddClass(className) {\r\n        (this._afterAddClasses = this._afterAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterRemoveClass(className) {\r\n        (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterStyles(styles) {\r\n        this._afterStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterClearStyles(propertyNames) {\r\n        this._afterStyles = this._afterStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._afterStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Play the animation.\r\n     */\r\n    play(opts) {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        // this is the top level animation and is in full control\r\n        // of when the async play() should actually kick off\r\n        // if there is no duration then it'll set the TO property immediately\r\n        // if there is a duration, then it'll stage all animations at the\r\n        // FROM property and transition duration, wait a few frames, then\r\n        // kick off the animation by setting the TO property for each animation\r\n        this._isAsync = this._hasDuration(opts);\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // recursively kicks off the correct progress step for each child animation\r\n        // ******** DOM WRITE ****************\r\n        this._playInit(opts);\r\n        // doubling up RAFs since this animation was probably triggered\r\n        // from an input event, and just having one RAF would have this code\r\n        // run within the same frame as the triggering input event, and the\r\n        // input event probably already did way too much work for one frame\r\n        raf(() => {\r\n            raf(() => {\r\n                this._playDomInspect(opts);\r\n            });\r\n        });\r\n    }\r\n    playAsync(opts) {\r\n        return new Promise(resolve => {\r\n            this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\r\n            this.play(opts);\r\n            return this;\r\n        });\r\n    }\r\n    playSync() {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (!this._destroyed) {\r\n            const opts = { duration: 0 };\r\n            this._isAsync = false;\r\n            this._clearAsync();\r\n            this._playInit(opts);\r\n            this._playDomInspect(opts);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playInit(opts) {\r\n        // always default that an animation does not tween\r\n        // a tween requires that an Animation class has an element\r\n        // and that it has at least one FROM/TO effect\r\n        // and that the FROM/TO effect can tween numeric values\r\n        this._hasTweenEffect = false;\r\n        this.isPlaying = true;\r\n        this.hasCompleted = false;\r\n        this._hasDur = (this.getDuration(opts) > DURATION_MIN);\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playInit(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // if there is a duration then we want to start at step 0\r\n            // ******** DOM WRITE ****************\r\n            this._progress(0);\r\n            // add the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _playDomInspect(opts) {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        // ******** DOM WRITE ****************\r\n        this._beforeAnimation();\r\n        // for the root animation only\r\n        // set the async TRANSITION END event\r\n        // and run onFinishes when the transition ends\r\n        const dur = this.getDuration(opts);\r\n        if (this._isAsync) {\r\n            this._asyncEnd(dur, true);\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._playProgress(opts);\r\n        if (this._isAsync && !this._destroyed) {\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            raf(() => {\r\n                this._playToStep(1);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playProgress(opts) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playProgress(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // set the CSS TRANSITION duration/easing\r\n            // ******** DOM WRITE ****************\r\n            this._setTrans(this.getDuration(opts), false);\r\n        }\r\n        else {\r\n            // this animation does not have a duration, so it should not animate\r\n            // just go straight to the TO properties and call it done\r\n            // ******** DOM WRITE ****************\r\n            this._progress(1);\r\n            // since there was no animation, immediately run the after\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // this animation has no duration, so it has finished\r\n            // other animations could still be running\r\n            this._didFinish(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playToStep(stepValue) {\r\n        if (!this._destroyed) {\r\n            const children = this._childAnimations;\r\n            if (children) {\r\n                for (const child of children) {\r\n                    // ******** DOM WRITE ****************\r\n                    child._playToStep(stepValue);\r\n                }\r\n            }\r\n            if (this._hasDur) {\r\n                // browser had some time to render everything in place\r\n                // and the transition duration/easing is set\r\n                // now set the TO properties which will trigger the transition to begin\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _asyncEnd(dur, shouldComplete) {\r\n        const self = this;\r\n        const onTransitionEnd = () => {\r\n            // congrats! a successful transition completed!\r\n            // ensure transition end events and timeouts have been cleared\r\n            self._clearAsync();\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd();\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        const onTransitionFallback = () => {\r\n            // oh noz! the transition end event didn't fire in time!\r\n            // instead the fallback timer when first\r\n            // if all goes well this fallback should never fire\r\n            // clear the other async end events from firing\r\n            self._timerId = undefined;\r\n            self._clearAsync();\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd(shouldComplete ? 1 : 0);\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        // set the TRANSITION END event on one of the transition elements\r\n        self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\r\n        // set a fallback timeout if the transition end event never fires, or is too slow\r\n        // transition end fallback: (animation duration + XXms)\r\n        self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playEnd(stepValue) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playEnd(stepValue);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            if (stepValue !== undefined) {\r\n                // too late to have a smooth animation, just finish it\r\n                // ******** DOM WRITE ****************\r\n                this._setTrans(0, true);\r\n                // ensure the ending progress step gets rendered\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // remove the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(false);\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDuration(opts) {\r\n        if (this.getDuration(opts) > DURATION_MIN) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDuration(opts)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDomReads() {\r\n        if (this._readCallbacks && this._readCallbacks.length > 0) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDomReads()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Immediately stop at the end of the animation.\r\n     */\r\n    stop(stepValue = 1) {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        this._hasDur = true;\r\n        this._playEnd(stepValue);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * NO RECURSION\r\n     */\r\n    _clearAsync() {\r\n        if (this._unregisterTrnsEnd) {\r\n            this._unregisterTrnsEnd();\r\n        }\r\n        if (this._timerId) {\r\n            clearTimeout(this._timerId);\r\n        }\r\n        this._timerId = this._unregisterTrnsEnd = undefined;\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _progress(stepValue) {\r\n        // bread 'n butter\r\n        let val;\r\n        const elements = this._elements;\r\n        const effects = this._fxProperties;\r\n        if (!elements || elements.length === 0 || !effects || this._destroyed) {\r\n            return;\r\n        }\r\n        // flip the number if we're going in reverse\r\n        if (this._isReverse) {\r\n            stepValue = 1 - stepValue;\r\n        }\r\n        let i = 0;\r\n        let j = 0;\r\n        let finalTransform = '';\r\n        let fx;\r\n        for (i = 0; i < effects.length; i++) {\r\n            fx = effects[i];\r\n            if (fx.from && fx.to) {\r\n                const fromNum = fx.from.num;\r\n                const toNum = fx.to.num;\r\n                const tweenEffect = (fromNum !== toNum);\r\n                if (tweenEffect) {\r\n                    this._hasTweenEffect = true;\r\n                }\r\n                if (stepValue === 0) {\r\n                    // FROM\r\n                    val = fx.from.val;\r\n                }\r\n                else if (stepValue === 1) {\r\n                    // TO\r\n                    val = fx.to.val;\r\n                }\r\n                else if (tweenEffect) {\r\n                    // EVERYTHING IN BETWEEN\r\n                    const valNum = (((toNum - fromNum) * stepValue) + fromNum);\r\n                    const unit = fx.to.effectUnit;\r\n                    val = valNum + unit;\r\n                }\r\n                if (val !== null) {\r\n                    const prop = fx.effectName;\r\n                    if (fx.trans) {\r\n                        finalTransform += prop + '(' + val + ') ';\r\n                    }\r\n                    else {\r\n                        for (j = 0; j < elements.length; j++) {\r\n                            // ******** DOM WRITE ****************\r\n                            elements[j].style.setProperty(prop, val);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // place all transforms on the same property\r\n        if (finalTransform.length > 0) {\r\n            if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\r\n                finalTransform += 'translateZ(0px)';\r\n            }\r\n            for (i = 0; i < elements.length; i++) {\r\n                // ******** DOM WRITE ****************\r\n                elements[i].style.setProperty('transform', finalTransform);\r\n                elements[i].style.setProperty('-webkit-transform', finalTransform);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _setTrans(dur, forcedLinearEasing) {\r\n        // Transition is not enabled if there are not effects\r\n        const elements = this._elements;\r\n        if (!elements || elements.length === 0 || !this._fxProperties) {\r\n            return;\r\n        }\r\n        // set the TRANSITION properties inline on the element\r\n        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\r\n        const durString = dur + 'ms';\r\n        for (const { style } of elements) {\r\n            if (dur > 0) {\r\n                // ******** DOM WRITE ****************\r\n                style.transitionDuration = durString;\r\n                // each animation can have a different easing\r\n                if (easing !== null) {\r\n                    // ******** DOM WRITE ****************\r\n                    style.transitionTimingFunction = easing;\r\n                }\r\n            }\r\n            else {\r\n                style.transitionDuration = '0';\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _beforeAnimation() {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        this._fireBeforeReadFunc();\r\n        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\r\n        // fire off all the \"before\" function that have DOM WRITES in them\r\n        // ******** DOM WRITE ****************\r\n        this._fireBeforeWriteFunc();\r\n        // stage all of the before css classes and inline styles\r\n        // ******** DOM WRITE ****************\r\n        this._setBeforeStyles();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _setBeforeStyles() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._setBeforeStyles();\r\n            }\r\n        }\r\n        const elements = this._elements;\r\n        // before the animations have started\r\n        // only set before styles if animation is not reversed\r\n        if (!elements || elements.length === 0 || this._isReverse) {\r\n            return;\r\n        }\r\n        const addClasses = this._beforeAddClasses;\r\n        const removeClasses = this._beforeRemoveClasses;\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // css classes to add before the animation\r\n            if (addClasses) {\r\n                for (const c of addClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.add(c);\r\n                }\r\n            }\r\n            // css classes to remove before the animation\r\n            if (removeClasses) {\r\n                for (const c of removeClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.remove(c);\r\n                }\r\n            }\r\n            // inline styles to add before the animation\r\n            if (this._beforeStyles) {\r\n                for (const [key, value] of Object.entries(this._beforeStyles)) {\r\n                    // ******** DOM WRITE ****************\r\n                    el.style.setProperty(key, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * RECURSION\r\n     */\r\n    _fireBeforeReadFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM READ ****************\r\n                child._fireBeforeReadFunc();\r\n            }\r\n        }\r\n        const readFunctions = this._readCallbacks;\r\n        if (readFunctions) {\r\n            for (const callback of readFunctions) {\r\n                // ******** DOM READ ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _fireBeforeWriteFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._fireBeforeWriteFunc();\r\n            }\r\n        }\r\n        const writeFunctions = this._writeCallbacks;\r\n        if (writeFunctions) {\r\n            for (const callback of writeFunctions) {\r\n                // ******** DOM WRITE ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     */\r\n    _setAfterStyles() {\r\n        const elements = this._elements;\r\n        if (!elements) {\r\n            return;\r\n        }\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // remove the transition duration/easing\r\n            // ******** DOM WRITE ****************\r\n            el.style.transitionDuration = el.style.transitionTimingFunction = '';\r\n            if (this._isReverse) {\r\n                // finished in reverse direction\r\n                // css classes that were added before the animation should be removed\r\n                const beforeAddClasses = this._beforeAddClasses;\r\n                if (beforeAddClasses) {\r\n                    for (const c of beforeAddClasses) {\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // css classes that were removed before the animation should be added\r\n                const beforeRemoveClasses = this._beforeRemoveClasses;\r\n                if (beforeRemoveClasses) {\r\n                    for (const c of beforeRemoveClasses) {\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // inline styles that were added before the animation should be removed\r\n                const beforeStyles = this._beforeStyles;\r\n                if (beforeStyles) {\r\n                    for (const propName of Object.keys(beforeStyles)) {\r\n                        // ******** DOM WRITE ****************\r\n                        el.style.removeProperty(propName);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // finished in forward direction\r\n                // css classes to add after the animation\r\n                const afterAddClasses = this._afterAddClasses;\r\n                if (afterAddClasses) {\r\n                    for (const c of afterAddClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // css classes to remove after the animation\r\n                const afterRemoveClasses = this._afterRemoveClasses;\r\n                if (afterRemoveClasses) {\r\n                    for (const c of afterRemoveClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // inline styles to add after the animation\r\n                const afterStyles = this._afterStyles;\r\n                if (afterStyles) {\r\n                    for (const [key, value] of Object.entries(afterStyles)) {\r\n                        el.style.setProperty(key, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _willChange(addWillChange) {\r\n        let wc;\r\n        const effects = this._fxProperties;\r\n        let willChange;\r\n        if (addWillChange && effects) {\r\n            wc = [];\r\n            for (const effect of effects) {\r\n                const propWC = effect.wc;\r\n                if (propWC === 'webkitTransform') {\r\n                    wc.push('transform', '-webkit-transform');\r\n                }\r\n                else if (propWC !== undefined) {\r\n                    wc.push(propWC);\r\n                }\r\n            }\r\n            willChange = wc.join(',');\r\n        }\r\n        else {\r\n            willChange = '';\r\n        }\r\n        const elements = this._elements;\r\n        if (elements) {\r\n            for (const el of elements) {\r\n                // ******** DOM WRITE ****************\r\n                el.style.setProperty('will-change', willChange);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Start the animation with a user controlled progress.\r\n     */\r\n    progressStart() {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // ******** DOM READ/WRITE ****************\r\n        this._beforeAnimation();\r\n        // ******** DOM WRITE ****************\r\n        this._progressStart();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressStart() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressStart();\r\n            }\r\n        }\r\n        // force no duration, linear easing\r\n        // ******** DOM WRITE ****************\r\n        this._setTrans(0, true);\r\n        // ******** DOM WRITE ****************\r\n        this._willChange(true);\r\n    }\r\n    /**\r\n     * Set the progress step for this animation.\r\n     * progressStep() is not debounced, so it should not be called faster than 60FPS.\r\n     */\r\n    progressStep(stepValue) {\r\n        // only update if the last update was more than 16ms ago\r\n        stepValue = Math.min(1, Math.max(0, stepValue));\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child.progressStep(stepValue);\r\n            }\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._progress(stepValue);\r\n    }\r\n    /**\r\n     * End the progress animation.\r\n     */\r\n    progressEnd(shouldComplete, currentStepValue, dur = -1) {\r\n        if (this._isReverse) {\r\n            // if the animation is going in reverse then\r\n            // flip the step value: 0 becomes 1, 1 becomes 0\r\n            currentStepValue = 1 - currentStepValue;\r\n        }\r\n        const stepValue = shouldComplete ? 1 : 0;\r\n        const diff = Math.abs(currentStepValue - stepValue);\r\n        if (dur < 0) {\r\n            dur = this._duration || 0;\r\n        }\r\n        else if (diff < 0.05) {\r\n            dur = 0;\r\n        }\r\n        this._isAsync = (dur > 30);\r\n        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\r\n        if (this._isAsync) {\r\n            // for the root animation only\r\n            // set the async TRANSITION END event\r\n            // and run onFinishes when the transition ends\r\n            // ******** DOM WRITE ****************\r\n            this._asyncEnd(dur, shouldComplete);\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            if (!this._destroyed) {\r\n                raf(() => {\r\n                    this._playToStep(stepValue);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressEnd(shouldComplete, stepValue, dur, isAsync) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressEnd(shouldComplete, stepValue, dur, isAsync);\r\n            }\r\n        }\r\n        if (!isAsync) {\r\n            // stop immediately\r\n            // set all the animations to their final position\r\n            // ******** DOM WRITE ****************\r\n            this._progress(stepValue);\r\n            this._willChange(false);\r\n            this._setAfterStyles();\r\n            this._didFinish(shouldComplete);\r\n        }\r\n        else {\r\n            // animate it back to it's ending position\r\n            this.isPlaying = true;\r\n            this.hasCompleted = false;\r\n            this._hasDur = true;\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n            this._setTrans(dur, false);\r\n        }\r\n    }\r\n    /**\r\n     * Add a callback to fire when the animation has finished.\r\n     */\r\n    onFinish(callback, opts) {\r\n        if (opts && opts.clearExistingCallbacks) {\r\n            this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\r\n        }\r\n        if (opts && opts.oneTimeCallback) {\r\n            this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\r\n            this._onFinishOneTimeCallbacks.push(callback);\r\n        }\r\n        else {\r\n            this._onFinishCallbacks = this._onFinishCallbacks || [];\r\n            this._onFinishCallbacks.push(callback);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\r\n            }\r\n        }\r\n        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\r\n            this._didFinish(hasCompleted);\r\n        }\r\n    }\r\n    /**\r\n     * NO RECURSION\r\n     */\r\n    _didFinish(hasCompleted) {\r\n        this.isPlaying = false;\r\n        this.hasCompleted = hasCompleted;\r\n        if (this._onFinishCallbacks) {\r\n            // run all finish callbacks\r\n            for (const callback of this._onFinishCallbacks) {\r\n                callback(this);\r\n            }\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            // run all \"onetime\" finish callbacks\r\n            for (const callback of this._onFinishOneTimeCallbacks) {\r\n                callback(this);\r\n            }\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Reverse the animation.\r\n     */\r\n    reverse(shouldReverse = true) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.reverse(shouldReverse);\r\n            }\r\n        }\r\n        this._isReverse = !!shouldReverse;\r\n        return this;\r\n    }\r\n    /**\r\n     * Recursively destroy this animation and all child animations.\r\n     */\r\n    destroy() {\r\n        this._didFinish(false);\r\n        this._destroyed = true;\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.destroy();\r\n            }\r\n        }\r\n        this._clearAsync();\r\n        if (this._elements) {\r\n            this._elements.length = 0;\r\n        }\r\n        if (this._readCallbacks) {\r\n            this._readCallbacks.length = 0;\r\n        }\r\n        if (this._writeCallbacks) {\r\n            this._writeCallbacks.length = 0;\r\n        }\r\n        this.parent = undefined;\r\n        if (this._childAnimations) {\r\n            this._childAnimations.length = 0;\r\n        }\r\n        if (this._onFinishCallbacks) {\r\n            this._onFinishCallbacks.length = 0;\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _transEl() {\r\n        // get the lowest level element that has an Animator\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                const targetEl = child._transEl();\r\n                if (targetEl) {\r\n                    return targetEl;\r\n                }\r\n            }\r\n        }\r\n        return (this._hasTweenEffect &&\r\n            this._hasDur &&\r\n            this._elements !== undefined &&\r\n            this._elements.length > 0 ?\r\n            this._elements[0] : null);\r\n    }\r\n}\n\nconst create = (animationBuilder, baseEl, opts) => {\r\n    if (animationBuilder) {\r\n        return animationBuilder(Animator, baseEl, opts);\r\n    }\r\n    return Promise.resolve(new Animator());\r\n};\n\n\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=index-69c37885-js-es2015.js.map","const transitionEnd = (el, callback) => {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    const unregister = () => {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    };\r\n    const onTransitionEnd = (ev) => {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    };\r\n    if (el) {\r\n        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n        el.addEventListener('transitionend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('transitionend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n};\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\r\nconst DURATION_MIN = 32;\r\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\r\nconst TRANSFORM_PROPS = {\r\n    'translateX': 1,\r\n    'translateY': 1,\r\n    'translateZ': 1,\r\n    'scale': 1,\r\n    'scaleX': 1,\r\n    'scaleY': 1,\r\n    'scaleZ': 1,\r\n    'rotate': 1,\r\n    'rotateX': 1,\r\n    'rotateY': 1,\r\n    'rotateZ': 1,\r\n    'skewX': 1,\r\n    'skewY': 1,\r\n    'perspective': 1\r\n};\r\nconst win = typeof window !== 'undefined' ? window : {};\r\nconst raf = win.requestAnimationFrame\r\n    ? win.requestAnimationFrame.bind(win)\r\n    : (f) => f(Date.now());\r\nclass Animator {\r\n    constructor() {\r\n        this._hasDur = false;\r\n        this._hasTweenEffect = false;\r\n        this._isAsync = false;\r\n        this._isReverse = false;\r\n        this._destroyed = false;\r\n        this.hasChildren = false;\r\n        this.isPlaying = false;\r\n        this.hasCompleted = false;\r\n    }\r\n    addElement(el) {\r\n        if (el != null) {\r\n            if (el.length > 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    this._addEl(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                this._addEl(el);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _addEl(el) {\r\n        if (el.nodeType === 1) {\r\n            (this._elements = this._elements || []).push(el);\r\n        }\r\n    }\r\n    /**\r\n     * Add a child animation to this animation.\r\n     */\r\n    add(childAnimation) {\r\n        childAnimation.parent = this;\r\n        this.hasChildren = true;\r\n        (this._childAnimations = this._childAnimations || []).push(childAnimation);\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the duration of this animation. If this animation does\r\n     * not have a duration, then it'll get the duration from its parent.\r\n     */\r\n    getDuration(opts) {\r\n        if (opts && opts.duration !== undefined) {\r\n            return opts.duration;\r\n        }\r\n        else if (this._duration !== undefined) {\r\n            return this._duration;\r\n        }\r\n        else if (this.parent) {\r\n            return this.parent.getDuration();\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Returns if the animation is a root one.\r\n     */\r\n    isRoot() {\r\n        return !this.parent;\r\n    }\r\n    /**\r\n     * Set the duration for this animation.\r\n     */\r\n    duration(milliseconds) {\r\n        this._duration = milliseconds;\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the easing of this animation. If this animation does\r\n     * not have an easing, then it'll get the easing from its parent.\r\n     */\r\n    getEasing() {\r\n        if (this._isReverse && this._reversedEasingName !== undefined) {\r\n            return this._reversedEasingName;\r\n        }\r\n        return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\r\n    }\r\n    /**\r\n     * Set the easing for this animation.\r\n     */\r\n    easing(name) {\r\n        this._easingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Set the easing for this reversed animation.\r\n     */\r\n    easingReverse(name) {\r\n        this._reversedEasingName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"from\" value for a specific property.\r\n     */\r\n    from(prop, val) {\r\n        this._addProp('from', prop, val);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add the \"to\" value for a specific property.\r\n     */\r\n    to(prop, val, clearProperyAfterTransition = false) {\r\n        const fx = this._addProp('to', prop, val);\r\n        if (clearProperyAfterTransition) {\r\n            // if this effect is a transform then clear the transform effect\r\n            // otherwise just clear the actual property\r\n            this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Shortcut to add both the \"from\" and \"to\" for the same property.\r\n     */\r\n    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\r\n        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _getProp(name) {\r\n        if (this._fxProperties) {\r\n            return this._fxProperties.find(prop => prop.effectName === name);\r\n        }\r\n        return undefined;\r\n    }\r\n    _addProp(state, prop, val) {\r\n        let fxProp = this._getProp(prop);\r\n        if (!fxProp) {\r\n            // first time we've see this EffectProperty\r\n            const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\r\n            fxProp = {\r\n                effectName: prop,\r\n                trans: shouldTrans,\r\n                // add the will-change property for transforms or opacity\r\n                wc: (shouldTrans ? 'transform' : prop)\r\n            };\r\n            (this._fxProperties = this._fxProperties || []).push(fxProp);\r\n        }\r\n        // add from/to EffectState to the EffectProperty\r\n        const fxState = {\r\n            val,\r\n            num: 0,\r\n            effectUnit: '',\r\n        };\r\n        fxProp[state] = fxState;\r\n        if (typeof val === 'string' && val.indexOf(' ') < 0) {\r\n            const r = val.match(CSS_VALUE_REGEX);\r\n            if (r) {\r\n                const num = parseFloat(r[1]);\r\n                if (!isNaN(num)) {\r\n                    fxState.num = num;\r\n                }\r\n                fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\r\n            }\r\n        }\r\n        else if (typeof val === 'number') {\r\n            fxState.num = val;\r\n        }\r\n        return fxProp;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeAddClass(className) {\r\n        (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeRemoveClass(className) {\r\n        (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeStyles(styles) {\r\n        this._beforeStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * before the animation begins.\r\n     */\r\n    beforeClearStyles(propertyNames) {\r\n        this._beforeStyles = this._beforeStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._beforeStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM reads, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddRead(domReadFn) {\r\n        (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add a function which contains DOM writes, which will run\r\n     * before the animation begins.\r\n     */\r\n    beforeAddWrite(domWriteFn) {\r\n        (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Add CSS class to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterAddClass(className) {\r\n        (this._afterAddClasses = this._afterAddClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove CSS class from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterRemoveClass(className) {\r\n        (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\r\n        return this;\r\n    }\r\n    /**\r\n     * Set CSS inline styles to this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterStyles(styles) {\r\n        this._afterStyles = styles;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clear CSS inline styles from this animation's elements\r\n     * after the animation finishes.\r\n     */\r\n    afterClearStyles(propertyNames) {\r\n        this._afterStyles = this._afterStyles || {};\r\n        for (const prop of propertyNames) {\r\n            this._afterStyles[prop] = '';\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Play the animation.\r\n     */\r\n    play(opts) {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        // this is the top level animation and is in full control\r\n        // of when the async play() should actually kick off\r\n        // if there is no duration then it'll set the TO property immediately\r\n        // if there is a duration, then it'll stage all animations at the\r\n        // FROM property and transition duration, wait a few frames, then\r\n        // kick off the animation by setting the TO property for each animation\r\n        this._isAsync = this._hasDuration(opts);\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // recursively kicks off the correct progress step for each child animation\r\n        // ******** DOM WRITE ****************\r\n        this._playInit(opts);\r\n        // doubling up RAFs since this animation was probably triggered\r\n        // from an input event, and just having one RAF would have this code\r\n        // run within the same frame as the triggering input event, and the\r\n        // input event probably already did way too much work for one frame\r\n        raf(() => {\r\n            raf(() => {\r\n                this._playDomInspect(opts);\r\n            });\r\n        });\r\n    }\r\n    playAsync(opts) {\r\n        return new Promise(resolve => {\r\n            this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\r\n            this.play(opts);\r\n            return this;\r\n        });\r\n    }\r\n    playSync() {\r\n        // If the animation was already invalidated (it did finish), do nothing\r\n        if (!this._destroyed) {\r\n            const opts = { duration: 0 };\r\n            this._isAsync = false;\r\n            this._clearAsync();\r\n            this._playInit(opts);\r\n            this._playDomInspect(opts);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playInit(opts) {\r\n        // always default that an animation does not tween\r\n        // a tween requires that an Animation class has an element\r\n        // and that it has at least one FROM/TO effect\r\n        // and that the FROM/TO effect can tween numeric values\r\n        this._hasTweenEffect = false;\r\n        this.isPlaying = true;\r\n        this.hasCompleted = false;\r\n        this._hasDur = (this.getDuration(opts) > DURATION_MIN);\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playInit(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // if there is a duration then we want to start at step 0\r\n            // ******** DOM WRITE ****************\r\n            this._progress(0);\r\n            // add the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _playDomInspect(opts) {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        // ******** DOM WRITE ****************\r\n        this._beforeAnimation();\r\n        // for the root animation only\r\n        // set the async TRANSITION END event\r\n        // and run onFinishes when the transition ends\r\n        const dur = this.getDuration(opts);\r\n        if (this._isAsync) {\r\n            this._asyncEnd(dur, true);\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._playProgress(opts);\r\n        if (this._isAsync && !this._destroyed) {\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            raf(() => {\r\n                this._playToStep(1);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playProgress(opts) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playProgress(opts);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            // set the CSS TRANSITION duration/easing\r\n            // ******** DOM WRITE ****************\r\n            this._setTrans(this.getDuration(opts), false);\r\n        }\r\n        else {\r\n            // this animation does not have a duration, so it should not animate\r\n            // just go straight to the TO properties and call it done\r\n            // ******** DOM WRITE ****************\r\n            this._progress(1);\r\n            // since there was no animation, immediately run the after\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // this animation has no duration, so it has finished\r\n            // other animations could still be running\r\n            this._didFinish(true);\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playToStep(stepValue) {\r\n        if (!this._destroyed) {\r\n            const children = this._childAnimations;\r\n            if (children) {\r\n                for (const child of children) {\r\n                    // ******** DOM WRITE ****************\r\n                    child._playToStep(stepValue);\r\n                }\r\n            }\r\n            if (this._hasDur) {\r\n                // browser had some time to render everything in place\r\n                // and the transition duration/easing is set\r\n                // now set the TO properties which will trigger the transition to begin\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     * ROOT ANIMATION\r\n     */\r\n    _asyncEnd(dur, shouldComplete) {\r\n        const self = this;\r\n        const onTransitionEnd = () => {\r\n            // congrats! a successful transition completed!\r\n            // ensure transition end events and timeouts have been cleared\r\n            self._clearAsync();\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd();\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        const onTransitionFallback = () => {\r\n            // oh noz! the transition end event didn't fire in time!\r\n            // instead the fallback timer when first\r\n            // if all goes well this fallback should never fire\r\n            // clear the other async end events from firing\r\n            self._timerId = undefined;\r\n            self._clearAsync();\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            self._playEnd(shouldComplete ? 1 : 0);\r\n            // transition finished\r\n            self._didFinishAll(shouldComplete, true, false);\r\n        };\r\n        // set the TRANSITION END event on one of the transition elements\r\n        self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\r\n        // set a fallback timeout if the transition end event never fires, or is too slow\r\n        // transition end fallback: (animation duration + XXms)\r\n        self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _playEnd(stepValue) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._playEnd(stepValue);\r\n            }\r\n        }\r\n        if (this._hasDur) {\r\n            if (stepValue !== undefined) {\r\n                // too late to have a smooth animation, just finish it\r\n                // ******** DOM WRITE ****************\r\n                this._setTrans(0, true);\r\n                // ensure the ending progress step gets rendered\r\n                // ******** DOM WRITE ****************\r\n                this._progress(stepValue);\r\n            }\r\n            // set the after styles\r\n            // ******** DOM WRITE ****************\r\n            this._setAfterStyles();\r\n            // remove the will-change properties\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(false);\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDuration(opts) {\r\n        if (this.getDuration(opts) > DURATION_MIN) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDuration(opts)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _hasDomReads() {\r\n        if (this._readCallbacks && this._readCallbacks.length > 0) {\r\n            return true;\r\n        }\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                if (child._hasDomReads()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Immediately stop at the end of the animation.\r\n     */\r\n    stop(stepValue = 1) {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        this._hasDur = true;\r\n        this._playEnd(stepValue);\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * NO RECURSION\r\n     */\r\n    _clearAsync() {\r\n        if (this._unregisterTrnsEnd) {\r\n            this._unregisterTrnsEnd();\r\n        }\r\n        if (this._timerId) {\r\n            clearTimeout(this._timerId);\r\n        }\r\n        this._timerId = this._unregisterTrnsEnd = undefined;\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _progress(stepValue) {\r\n        // bread 'n butter\r\n        let val;\r\n        const elements = this._elements;\r\n        const effects = this._fxProperties;\r\n        if (!elements || elements.length === 0 || !effects || this._destroyed) {\r\n            return;\r\n        }\r\n        // flip the number if we're going in reverse\r\n        if (this._isReverse) {\r\n            stepValue = 1 - stepValue;\r\n        }\r\n        let i = 0;\r\n        let j = 0;\r\n        let finalTransform = '';\r\n        let fx;\r\n        for (i = 0; i < effects.length; i++) {\r\n            fx = effects[i];\r\n            if (fx.from && fx.to) {\r\n                const fromNum = fx.from.num;\r\n                const toNum = fx.to.num;\r\n                const tweenEffect = (fromNum !== toNum);\r\n                if (tweenEffect) {\r\n                    this._hasTweenEffect = true;\r\n                }\r\n                if (stepValue === 0) {\r\n                    // FROM\r\n                    val = fx.from.val;\r\n                }\r\n                else if (stepValue === 1) {\r\n                    // TO\r\n                    val = fx.to.val;\r\n                }\r\n                else if (tweenEffect) {\r\n                    // EVERYTHING IN BETWEEN\r\n                    const valNum = (((toNum - fromNum) * stepValue) + fromNum);\r\n                    const unit = fx.to.effectUnit;\r\n                    val = valNum + unit;\r\n                }\r\n                if (val !== null) {\r\n                    const prop = fx.effectName;\r\n                    if (fx.trans) {\r\n                        finalTransform += prop + '(' + val + ') ';\r\n                    }\r\n                    else {\r\n                        for (j = 0; j < elements.length; j++) {\r\n                            // ******** DOM WRITE ****************\r\n                            elements[j].style.setProperty(prop, val);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // place all transforms on the same property\r\n        if (finalTransform.length > 0) {\r\n            if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\r\n                finalTransform += 'translateZ(0px)';\r\n            }\r\n            for (i = 0; i < elements.length; i++) {\r\n                // ******** DOM WRITE ****************\r\n                elements[i].style.setProperty('transform', finalTransform);\r\n                elements[i].style.setProperty('-webkit-transform', finalTransform);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _setTrans(dur, forcedLinearEasing) {\r\n        // Transition is not enabled if there are not effects\r\n        const elements = this._elements;\r\n        if (!elements || elements.length === 0 || !this._fxProperties) {\r\n            return;\r\n        }\r\n        // set the TRANSITION properties inline on the element\r\n        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\r\n        const durString = dur + 'ms';\r\n        for (const { style } of elements) {\r\n            if (dur > 0) {\r\n                // ******** DOM WRITE ****************\r\n                style.transitionDuration = durString;\r\n                // each animation can have a different easing\r\n                if (easing !== null) {\r\n                    // ******** DOM WRITE ****************\r\n                    style.transitionTimingFunction = easing;\r\n                }\r\n            }\r\n            else {\r\n                style.transitionDuration = '0';\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _beforeAnimation() {\r\n        // fire off all the \"before\" function that have DOM READS in them\r\n        // elements will be in the DOM, however visibily hidden\r\n        // so we can read their dimensions if need be\r\n        // ******** DOM READ ****************\r\n        this._fireBeforeReadFunc();\r\n        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\r\n        // fire off all the \"before\" function that have DOM WRITES in them\r\n        // ******** DOM WRITE ****************\r\n        this._fireBeforeWriteFunc();\r\n        // stage all of the before css classes and inline styles\r\n        // ******** DOM WRITE ****************\r\n        this._setBeforeStyles();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _setBeforeStyles() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._setBeforeStyles();\r\n            }\r\n        }\r\n        const elements = this._elements;\r\n        // before the animations have started\r\n        // only set before styles if animation is not reversed\r\n        if (!elements || elements.length === 0 || this._isReverse) {\r\n            return;\r\n        }\r\n        const addClasses = this._beforeAddClasses;\r\n        const removeClasses = this._beforeRemoveClasses;\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // css classes to add before the animation\r\n            if (addClasses) {\r\n                for (const c of addClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.add(c);\r\n                }\r\n            }\r\n            // css classes to remove before the animation\r\n            if (removeClasses) {\r\n                for (const c of removeClasses) {\r\n                    // ******** DOM WRITE ****************\r\n                    elementClassList.remove(c);\r\n                }\r\n            }\r\n            // inline styles to add before the animation\r\n            if (this._beforeStyles) {\r\n                for (const [key, value] of Object.entries(this._beforeStyles)) {\r\n                    // ******** DOM WRITE ****************\r\n                    el.style.setProperty(key, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM READ\r\n     * RECURSION\r\n     */\r\n    _fireBeforeReadFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM READ ****************\r\n                child._fireBeforeReadFunc();\r\n            }\r\n        }\r\n        const readFunctions = this._readCallbacks;\r\n        if (readFunctions) {\r\n            for (const callback of readFunctions) {\r\n                // ******** DOM READ ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _fireBeforeWriteFunc() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._fireBeforeWriteFunc();\r\n            }\r\n        }\r\n        const writeFunctions = this._writeCallbacks;\r\n        if (writeFunctions) {\r\n            for (const callback of writeFunctions) {\r\n                // ******** DOM WRITE ****************\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     */\r\n    _setAfterStyles() {\r\n        const elements = this._elements;\r\n        if (!elements) {\r\n            return;\r\n        }\r\n        for (const el of elements) {\r\n            const elementClassList = el.classList;\r\n            // remove the transition duration/easing\r\n            // ******** DOM WRITE ****************\r\n            el.style.transitionDuration = el.style.transitionTimingFunction = '';\r\n            if (this._isReverse) {\r\n                // finished in reverse direction\r\n                // css classes that were added before the animation should be removed\r\n                const beforeAddClasses = this._beforeAddClasses;\r\n                if (beforeAddClasses) {\r\n                    for (const c of beforeAddClasses) {\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // css classes that were removed before the animation should be added\r\n                const beforeRemoveClasses = this._beforeRemoveClasses;\r\n                if (beforeRemoveClasses) {\r\n                    for (const c of beforeRemoveClasses) {\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // inline styles that were added before the animation should be removed\r\n                const beforeStyles = this._beforeStyles;\r\n                if (beforeStyles) {\r\n                    for (const propName of Object.keys(beforeStyles)) {\r\n                        // ******** DOM WRITE ****************\r\n                        el.style.removeProperty(propName);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // finished in forward direction\r\n                // css classes to add after the animation\r\n                const afterAddClasses = this._afterAddClasses;\r\n                if (afterAddClasses) {\r\n                    for (const c of afterAddClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.add(c);\r\n                    }\r\n                }\r\n                // css classes to remove after the animation\r\n                const afterRemoveClasses = this._afterRemoveClasses;\r\n                if (afterRemoveClasses) {\r\n                    for (const c of afterRemoveClasses) {\r\n                        // ******** DOM WRITE ****************\r\n                        elementClassList.remove(c);\r\n                    }\r\n                }\r\n                // inline styles to add after the animation\r\n                const afterStyles = this._afterStyles;\r\n                if (afterStyles) {\r\n                    for (const [key, value] of Object.entries(afterStyles)) {\r\n                        el.style.setProperty(key, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * NO RECURSION\r\n     */\r\n    _willChange(addWillChange) {\r\n        let wc;\r\n        const effects = this._fxProperties;\r\n        let willChange;\r\n        if (addWillChange && effects) {\r\n            wc = [];\r\n            for (const effect of effects) {\r\n                const propWC = effect.wc;\r\n                if (propWC === 'webkitTransform') {\r\n                    wc.push('transform', '-webkit-transform');\r\n                }\r\n                else if (propWC !== undefined) {\r\n                    wc.push(propWC);\r\n                }\r\n            }\r\n            willChange = wc.join(',');\r\n        }\r\n        else {\r\n            willChange = '';\r\n        }\r\n        const elements = this._elements;\r\n        if (elements) {\r\n            for (const el of elements) {\r\n                // ******** DOM WRITE ****************\r\n                el.style.setProperty('will-change', willChange);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Start the animation with a user controlled progress.\r\n     */\r\n    progressStart() {\r\n        // ensure all past transition end events have been cleared\r\n        this._clearAsync();\r\n        // ******** DOM READ/WRITE ****************\r\n        this._beforeAnimation();\r\n        // ******** DOM WRITE ****************\r\n        this._progressStart();\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressStart() {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressStart();\r\n            }\r\n        }\r\n        // force no duration, linear easing\r\n        // ******** DOM WRITE ****************\r\n        this._setTrans(0, true);\r\n        // ******** DOM WRITE ****************\r\n        this._willChange(true);\r\n    }\r\n    /**\r\n     * Set the progress step for this animation.\r\n     * progressStep() is not debounced, so it should not be called faster than 60FPS.\r\n     */\r\n    progressStep(stepValue) {\r\n        // only update if the last update was more than 16ms ago\r\n        stepValue = Math.min(1, Math.max(0, stepValue));\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child.progressStep(stepValue);\r\n            }\r\n        }\r\n        // ******** DOM WRITE ****************\r\n        this._progress(stepValue);\r\n    }\r\n    /**\r\n     * End the progress animation.\r\n     */\r\n    progressEnd(shouldComplete, currentStepValue, dur = -1) {\r\n        if (this._isReverse) {\r\n            // if the animation is going in reverse then\r\n            // flip the step value: 0 becomes 1, 1 becomes 0\r\n            currentStepValue = 1 - currentStepValue;\r\n        }\r\n        const stepValue = shouldComplete ? 1 : 0;\r\n        const diff = Math.abs(currentStepValue - stepValue);\r\n        if (dur < 0) {\r\n            dur = this._duration || 0;\r\n        }\r\n        else if (diff < 0.05) {\r\n            dur = 0;\r\n        }\r\n        this._isAsync = (dur > 30);\r\n        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\r\n        if (this._isAsync) {\r\n            // for the root animation only\r\n            // set the async TRANSITION END event\r\n            // and run onFinishes when the transition ends\r\n            // ******** DOM WRITE ****************\r\n            this._asyncEnd(dur, shouldComplete);\r\n            // this animation has a duration so we need another RAF\r\n            // for the CSS TRANSITION properties to kick in\r\n            if (!this._destroyed) {\r\n                raf(() => {\r\n                    this._playToStep(stepValue);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * DOM WRITE\r\n     * RECURSION\r\n     */\r\n    _progressEnd(shouldComplete, stepValue, dur, isAsync) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                // ******** DOM WRITE ****************\r\n                child._progressEnd(shouldComplete, stepValue, dur, isAsync);\r\n            }\r\n        }\r\n        if (!isAsync) {\r\n            // stop immediately\r\n            // set all the animations to their final position\r\n            // ******** DOM WRITE ****************\r\n            this._progress(stepValue);\r\n            this._willChange(false);\r\n            this._setAfterStyles();\r\n            this._didFinish(shouldComplete);\r\n        }\r\n        else {\r\n            // animate it back to it's ending position\r\n            this.isPlaying = true;\r\n            this.hasCompleted = false;\r\n            this._hasDur = true;\r\n            // ******** DOM WRITE ****************\r\n            this._willChange(true);\r\n            this._setTrans(dur, false);\r\n        }\r\n    }\r\n    /**\r\n     * Add a callback to fire when the animation has finished.\r\n     */\r\n    onFinish(callback, opts) {\r\n        if (opts && opts.clearExistingCallbacks) {\r\n            this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\r\n        }\r\n        if (opts && opts.oneTimeCallback) {\r\n            this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\r\n            this._onFinishOneTimeCallbacks.push(callback);\r\n        }\r\n        else {\r\n            this._onFinishCallbacks = this._onFinishCallbacks || [];\r\n            this._onFinishCallbacks.push(callback);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * NO DOM\r\n     * RECURSION\r\n     */\r\n    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\r\n            }\r\n        }\r\n        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\r\n            this._didFinish(hasCompleted);\r\n        }\r\n    }\r\n    /**\r\n     * NO RECURSION\r\n     */\r\n    _didFinish(hasCompleted) {\r\n        this.isPlaying = false;\r\n        this.hasCompleted = hasCompleted;\r\n        if (this._onFinishCallbacks) {\r\n            // run all finish callbacks\r\n            for (const callback of this._onFinishCallbacks) {\r\n                callback(this);\r\n            }\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            // run all \"onetime\" finish callbacks\r\n            for (const callback of this._onFinishOneTimeCallbacks) {\r\n                callback(this);\r\n            }\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Reverse the animation.\r\n     */\r\n    reverse(shouldReverse = true) {\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.reverse(shouldReverse);\r\n            }\r\n        }\r\n        this._isReverse = !!shouldReverse;\r\n        return this;\r\n    }\r\n    /**\r\n     * Recursively destroy this animation and all child animations.\r\n     */\r\n    destroy() {\r\n        this._didFinish(false);\r\n        this._destroyed = true;\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                child.destroy();\r\n            }\r\n        }\r\n        this._clearAsync();\r\n        if (this._elements) {\r\n            this._elements.length = 0;\r\n        }\r\n        if (this._readCallbacks) {\r\n            this._readCallbacks.length = 0;\r\n        }\r\n        if (this._writeCallbacks) {\r\n            this._writeCallbacks.length = 0;\r\n        }\r\n        this.parent = undefined;\r\n        if (this._childAnimations) {\r\n            this._childAnimations.length = 0;\r\n        }\r\n        if (this._onFinishCallbacks) {\r\n            this._onFinishCallbacks.length = 0;\r\n        }\r\n        if (this._onFinishOneTimeCallbacks) {\r\n            this._onFinishOneTimeCallbacks.length = 0;\r\n        }\r\n    }\r\n    /**\r\n     * NO DOM\r\n     */\r\n    _transEl() {\r\n        // get the lowest level element that has an Animator\r\n        const children = this._childAnimations;\r\n        if (children) {\r\n            for (const child of children) {\r\n                const targetEl = child._transEl();\r\n                if (targetEl) {\r\n                    return targetEl;\r\n                }\r\n            }\r\n        }\r\n        return (this._hasTweenEffect &&\r\n            this._hasDur &&\r\n            this._elements !== undefined &&\r\n            this._elements.length > 0 ?\r\n            this._elements[0] : null);\r\n    }\r\n}\n\nconst create = (animationBuilder, baseEl, opts) => {\r\n    if (animationBuilder) {\r\n        return animationBuilder(Animator, baseEl, opts);\r\n    }\r\n    return Promise.resolve(new Animator());\r\n};\n\nexport { create };\n"]}